# Exact models

#src We generate a documentation page from this source file. 
#src Let's tell the user:
#md # This file is automatically generated from source code. 
#md # For usage examples refer to [Summary & Quick Examples](@ref exact_summary).

# ## Introduction
# The `ExactModel` is used to evaluate the objective exactly, without surrogate modelling
# (except for internal variable scaling).
# The derivatives are either user provided callbacks or can be deterimned using `ForwardDiff`
# or `FiniteDiff` automatically.

# ## Surrogate Model Interface Implementations

""" 
    ExactModel( func_indices, mop )

Exact Model type for evaluating the objective function `objf` directly.
Is instantiated by the corresponding `init_model` and `update_model` functions.
"""
struct ExactModel{ F, M <: Base.RefValue{<:AbstractMOP} } <: SurrogateModel
    func_indices :: F
    mop :: M
end
 
function ExactModel( func_indices, mop :: AbstractMOP )
    return ExactModel( func_indices, Ref(mop) )
end

# The can determine the behavior of an `ExactModel` using `ExactConfig`: 

"""
    ExactConfig(; gradients, jacobian = nothing, max_evals = typemax(Int64))

Configuration for an `ExactModel`.
`gradients` should be a vector of callbacks for the objective gradients **or** 
a `Symbol`, either `:autodiff` or `fdm`, to define the differentiation method 
to use on the objective.
Alternatively, a `jacobian` handle can be provided.
""" 
@with_kw struct ExactConfig <: SurrogateConfig
    max_evals :: Int64 = typemax(Int64)
    @assert max_evals > 1 "(ExactConfig) `max_evals` is too low."
end

needs_gradients(cfg::ExactConfig) = true

# There is no need for custom meta information:
struct ExactMeta <: SurrogateMeta end   # no construction meta data needed

# The remaining implementations are straightforward:
max_evals( emc :: ExactConfig ) = emc.max_evals
# We always deem the models fully linear:
fully_linear( em :: ExactModel ) = true
# They are not combinable to have individiual gradients availabe:
combinable( :: ExactConfig ) = false

# ## Construction

# All "construction" work is done in the `init_model` function:
function prepare_init_model(cfg :: ExactConfig, func_indices :: FunctionIndexIterable,
    mop :: AbstractMOP, scal :: AbstractVarScaler, id ::AbstractIterate, sdb :: AbstractSuperDB, ac :: AbstractConfig; kwargs...)
    return ExactMeta()
end

@doc "Return an ExactModel build from a VecFun `objf`. 
Model is the same inside and outside of criticality round."
function init_model(meta :: ExactMeta, cfg :: ExactConfig, func_indices :: FunctionIndexIterable,
    mop :: AbstractMOP, scal :: AbstractVarScaler, id ::AbstractIterate, sdb :: AbstractSuperDB, ac :: AbstractConfig; kwargs...)
    
    em = ExactModel(func_indices, mop)
    return em, meta
end

# We do not need the `improve_model` and `update_model` methods, so we keep the defaults.

# ## Evaluation
@doc "Evaluate the ExactModel `em` at scaled site `x̂`."
function eval_models( em :: ExactModel,scal :: AbstractVarScaler, x_scaled :: Vec )
    return eval_vec_mop_at_func_indices_at_scaled_site( em.mop[], em.func_indices, x_scaled, scal )
end

@memoize function func_index_and_relative_position_from_exact_model( em :: ExactModel, l :: Int )
    return func_index_and_relative_position_from_func_indices( em.func_indices , l :: Int )
end

@doc "Evaluate output `ℓ` of the ExactModel `em` at scaled site `x̂`."
function eval_models( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec, ℓ :: Int64)
    f_ind, rel_pos = func_index_and_relative_position_from_exact_model( em, ℓ )
    return eval_vec_mop_at_func_indices_at_scaled_site(em.mop[], [f_ind,], x_scaled, scal)[rel_pos]
end

@doc "Gradient vector of output `ℓ` of `em` at scaled site `x̂`."
function get_gradient( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec, ℓ :: Int64)
    mop = em.mop[]
    f_ind, rel_pos = func_index_and_relative_position_from_exact_model( em, ℓ )
    objf = _get( mop, f_ind )
    J = jacobian_of_unscaling( scal)
    x = untransform( x_scaled, scal )
    return _ensure_vec( J'get_objf_gradient( objf, x, rel_pos ) )
end

@doc "Jacobian Matrix of ExactModel `em` at scaled site `x̂`."
function get_jacobian( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec )
    mop = em.mop[]
    J = jacobian_of_unscaling(scal)
    x = untransform( x_scaled, scal )
    return reduce( vcat, 
        get_objf_jacobian( _get(mop, f_ind), x ) for f_ind = em.func_indices 
    ) * J
end

# ## [Summary & Quick Examples](@id exact_summary)

# ```julia
# using Morbit
# Morbit.print_all_logs()
# mop = MixedMOP(3)
#
# f1 = x -> sum( ( x .- 1 ).^2 
# f2 = x -> sum( ( x .+ 1 ).^2
# g1 = x -> 2 .* ( x .- 1 )
# g2 = x -> 2 .* ( x .+ 1 )
#
# add_objective!( mop, f1, ExactConfig(; gradients = [g1,]) )
# add_objective!( mop, f2, ExactConfig(; gradients = [g2,]) )
#
# x_fin, f_fin, _ = optimize( mop, [-π, ℯ, 0])
# ```