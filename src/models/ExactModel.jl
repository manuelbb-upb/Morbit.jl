# Exact models

#src We generate a documentation page from this source file. 
#src Let's tell the user:
#md # This file is automatically generated from source code. 
#md # For usage examples refer to [Summary & Quick Examples](@ref exact_summary).

# ## Introduction
# The `ExactModel` is used to evaluate the objective exactly, without surrogate modelling
# (except for internal variable scaling).
# The derivatives are either user provided callbacks or can be deterimned using `ForwardDiff`
# or `FiniteDiff` automatically.

# ## Surrogate Model Interface Implementations

""" 
    ExactModel( index, mop )

Exact Model type for evaluating the objective function `objf` directly.
Is instantiated by the corresponding `init_model` and `update_model` functions.
"""
struct ExactModel{M <: Base.RefValue } <: AbstractSurrogate
    func_index :: NLIndex
    mop :: M
end
 
function ExactModel( func_ind, mop :: AbstractMOP )
    return ExactModel( func_ind, Ref(mop) )
end

# The can determine the behavior of an `ExactModel` using `ExactConfig`: 

"""
    ExactConfig(; gradients, jacobian = nothing, max_evals = typemax(Int64))

Configuration for an `ExactModel`.
`gradients` should be a vector of callbacks for the objective gradients **or** 
a `Symbol`, either `:autodiff` or `fdm`, to define the differentiation method 
to use on the objective.
Alternatively, a `jacobian` handle can be provided.
""" 
@with_kw struct ExactConfig <: AbstractSurrogateConfig
    max_evals :: Int64 = typemax(Int64)
    @assert max_evals > 1 "(ExactConfig) `max_evals` is too low."
end

needs_gradients(cfg::ExactConfig) = true

# There is no need for custom meta information:
struct ExactMeta <: AbstractSurrogateMeta end   # no construction meta data needed

# The remaining implementations are straightforward:
num_outputs( emc :: ExactConfig ) = emc.num_outputs 
max_evals( emc :: ExactConfig ) = emc.max_evals
# We always deem the models fully linear:
fully_linear( em :: ExactModel ) = true
# They are not combinable to have individiual gradients availabe:
combinable( :: ExactConfig ) = false

# ## Construction

# All "construction" work is done in the `init_model` function:
function prepare_init_model(cfg :: ExactConfig, func_indices,
    mop, scal, id, sdb, ac; kwargs...
)
    return ExactMeta()
end

@doc "Return an ExactModel build from a VecFun `objf`. 
Model is the same inside and outside of criticality round."
function init_model(meta :: ExactMeta, cfg :: ExactConfig, 
    func_indices, mop, scal, id, sdb, ac; kwargs...
)
    em = ExactModel( first(func_indices), mop)
    return em, meta
end

# We do not need the `improve_model` and `update_model` methods, so we keep the defaults.

# ## Evaluation
@doc "Evaluate the ExactModel `em` at scaled site `x̂`."
function eval_models( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec )
    #return eval_vec_mop_at_func_indices_at_scaled_site( em.mop[], [em.func_index,], x_scaled, scal )
    return eval_objf( _get(em.mop[], em.func_index), untransform(x_scaled, scal) )
end

@doc "Gradient vector of output `ℓ` of `em` at scaled site `x̂`."
function get_gradient( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec, ℓ )
    mop = em.mop[]
    f_ind = em.func_index
    objf = _get( mop, f_ind )
    J = jacobian_of_unscaling( scal)
    x = untransform( x_scaled, scal )
    return _ensure_vec( J'_get_gradient( objf, x, ℓ ) )
end

@doc "Jacobian Matrix of ExactModel `em` at scaled site `x̂`."
function get_model_jacobian( em :: ExactModel, scal :: AbstractVarScaler, x_scaled :: Vec, rows = nothing )
    mop = em.mop[]
    J = jacobian_of_unscaling(scal)
    x = untransform( x_scaled, scal )
    f_ind = em.func_index
    partial_jac = if isnothing(rows) 
        _get_jacobian( _get(mop, f_ind), x )
    else
        _get_jacobian( _get(mop,f_ind), x, rows)
    end
    return partial_jac * J        
end

function get_jacobian(em :: ExactModel, scal :: AbstractVarScaler, x_s :: Vec )
    return get_model_jacobian(em, scal, x_s)
end

function get_jacobian(em :: ExactModel, scal :: AbstractVarScaler, x_s :: Vec, rows )
    return get_model_jacobian( em, scal, x_s, rows)
end

# ## [Summary & Quick Examples](@id exact_summary)

# ```julia
# using Morbit
# Morbit.print_all_logs()
# mop = MixedMOP(3)
#
# f1 = x -> sum( ( x .- 1 ).^2 
# f2 = x -> sum( ( x .+ 1 ).^2
# g1 = x -> 2 .* ( x .- 1 )
# g2 = x -> 2 .* ( x .+ 1 )
#
# add_objective!( mop, f1, ExactConfig(; gradients = [g1,]) )
# add_objective!( mop, f2, ExactConfig(; gradients = [g2,]) )
#
# x_fin, f_fin, _ = optimize( mop, [-π, ℯ, 0])
# ```