<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Two Parabolas ¬∑ Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/example_two_parabolas/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/iframeResizer.min.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../custom_logging/">Debug Info</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Two Parabolas</a><ul class="internal"><li><a class="tocitem" href="#Solve-using-Exact-Functions"><span>Solve using Exact Functions</span></a></li><li><a class="tocitem" href="#Solving-using-RBF-Surrogates"><span>Solving using RBF Surrogates</span></a></li><li><a class="tocitem" href="#Different-Starting-Points-and-Recycling-Data"><span>Different Starting Points and Recycling Data</span></a></li></ul></li><li><a class="tocitem" href="../example_zdt/">ZDT3</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Two Parabolas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Two Parabolas</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Two-Parabolas"><a class="docs-heading-anchor" href="#Two-Parabolas">Two Parabolas</a><a id="Two-Parabolas-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Parabolas" title="Permalink"></a></h1><p>The ‚Äútwo parabolas‚Äù problem in two dimensions reads as</p><p class="math-container">\[    \min_{ùê± ‚àà X }
    \begin{bmatrix} f‚ÇÅ(\mathbf{x}) \\ f‚ÇÇ(\mathbf{x}) \end{bmatrix} =
    \min_{\mathbf{x} ‚àà X}
    \begin{bmatrix}
    (x‚ÇÅ - 1)¬≤ + (x‚ÇÇ - 1)¬≤ \\
    (x‚ÇÅ + 1)¬≤ + (x‚ÇÇ + 1)¬≤
    \end{bmatrix}.\]</p><p>It is unconstrained if the feasible set is <span>$X = ‚Ñù^2$</span>. The individual minima <span>$[1,1]$</span> and <span>$[-1,-1]$</span> are such that (in the unconstrained case) the global Pareto Set is</p><p class="math-container">\[\mathcal{P}_{S} = \{ \mathbf{x} ‚àà ‚Ñù^2 : x‚ÇÅ = x‚ÇÇ, \, -1 \le x‚ÇÅ, x‚ÇÇ \le 1  \}.\]</p><h2 id="Solve-using-Exact-Functions"><a class="docs-heading-anchor" href="#Solve-using-Exact-Functions">Solve using Exact Functions</a><a id="Solve-using-Exact-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-using-Exact-Functions" title="Permalink"></a></h2><p>The gradients are easily calculated as</p><p class="math-container">\[\nabla f_1 (\mathbf x) = 2 \begin{bmatrix}
x_1 -1 \\ x_2 - 1 \end{bmatrix}, \;
\nabla f_2 (\mathbf x) = 2 \begin{bmatrix}
x_1 +1 \\ x_2 + 1 \end{bmatrix}, \;\]</p><p>We can provide them to the solver to find a critical point:</p><pre><code class="language-julia hljs">import Logging #src


using Morbit

f‚ÇÅ = x -&gt; sum( (x .- 1).^2 )
f‚ÇÇ = x -&gt; sum( (x .+ 1).^2 )
‚àáf‚ÇÅ = x -&gt; 2 .* ( x .- 1 )
‚àáf‚ÇÇ = x -&gt; 2 .* ( x .+ 1 )

mop = MixedMOP(2);  # problem with 2 variables
add_objective!(mop, f‚ÇÅ, ‚àáf‚ÇÅ )
add_objective!(mop, f‚ÇÇ, ‚àáf‚ÇÇ )

#  starting point
x‚ÇÄ = [ -œÄ ;  2.71828 ]

#  set maximum number of iterations
ac = AlgoConfig( max_iter = 20)
#  `optimize` will return parameter and result vectors as well
#  as an `Morbit.IterData` object.
x, fx, id = optimize( mop, x‚ÇÄ; algo_config = ac );
x</code></pre><p>Hopefully, <code>x</code> is critical, i.e., <code>x[1] ‚âà x[2]</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To print more information on what the solver is doing, you can use the <code>Logging</code> module:</p><pre><code class="language-julia hljs">import Logging: global_logger, ConsoleLogger
global_logger( ConsoleLogger( stderr, Morbit.loglevel4;
    meta_formatter = Morbit.morbit_formatter ) )</code></pre><p><code>loglevel4</code> is the most detailed and <code>loglevel1</code> is least detailed.</p></div></div><h3 id="Plotting-Iteration-Sites"><a class="docs-heading-anchor" href="#Plotting-Iteration-Sites">Plotting Iteration Sites</a><a id="Plotting-Iteration-Sites-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Iteration-Sites" title="Permalink"></a></h3><p>We can retrieve iteration data from <code>id</code> and the database <code>Morbit.db(id)</code></p><pre><code class="language-julia hljs">db = Morbit.db(id);
nothing #hide</code></pre><p>Let&#39;s retrieve the iteration sites. We convert to Tuples for easier plotting.</p><pre><code class="language-julia hljs">it_sites = Tuple.(Morbit.get_iterate_sites(db));
nothing #hide</code></pre><p>For Plotting we use CairoMakie</p><pre><code class="language-julia hljs">using CairoMakie

#  Pareto Set ‚âô line from (-1,-1) to (1,1)
fig, ax, _ = lines( [(-1,-1),(1,1)]; color = :blue, linewidth = 2,
    figure = (resolution = (600, 600),) )

#  Plot the iteration sites:
lines!(it_sites)
scatter!(it_sites;
    color = LinRange(0, 1, length(it_sites)),
    colormap = :winter
)

#  Plot function contours
Y = X = LinRange(-4, 4, 100)
Z‚ÇÅ = [ f‚ÇÅ([x;y]) for x ‚àà X, y ‚àà X ]
Z‚ÇÇ = [ f‚ÇÇ([x;y]) for x ‚àà X, y ‚àà X ]
levels = [ i.^2 for i = LinRange(.1, 6, 6) ]
contour!(X,Y,Z‚ÇÅ; colormap = :greens, levels = levels, linewidth = .5 )
contour!(X,Y,Z‚ÇÇ; colormap = :heat, levels = levels, linewidth = .5 )

#  Show the plot:
ax.title[] = &quot;Pareto Set and Iterates.&quot;
ax.xgridvisible[] = false
ax.ygridvisible[] = false

fig</code></pre><h2 id="Solving-using-RBF-Surrogates"><a class="docs-heading-anchor" href="#Solving-using-RBF-Surrogates">Solving using RBF Surrogates</a><a id="Solving-using-RBF-Surrogates-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-using-RBF-Surrogates" title="Permalink"></a></h2><p>Suppose now that we do not have access to the objective gradients and that the objectives also take some time to evaluate. In this situation, we could try to model them using surrogate models. To use radial basis function models, pass an <code>RbfConfig</code> when specifying the objective:</p><pre><code class="language-julia hljs">mop_rbf = MixedMOP()

#  Define the RBF surrogates
rbf_cfg = RbfConfig(
    kernel = :multiquadric,
    shape_parameter = &quot;20/Œî&quot;
)
#  Add objective functions to `mop_rbf`
add_objective!(mop_rbf, f‚ÇÅ, rbf_cfg )
add_objective!(mop_rbf, f‚ÇÇ, rbf_cfg )

#  only perform 10 iterations
ac = AlgoConfig( max_iter = 10 )
x, fx, id = optimize( mop, x‚ÇÄ; algo_config = ac )
x

it_sites_rbf = Tuple.(Morbit.get_iterate_sites(Morbit.db(id))) #hide
lines!(it_sites); #hide
scatter!(it_sites; color = :orange); #hide
nothing #hide</code></pre><p>The iteration sites are the orange circles:</p><pre><code class="language-julia hljs">fig #hide</code></pre><h2 id="Different-Starting-Points-and-Recycling-Data"><a class="docs-heading-anchor" href="#Different-Starting-Points-and-Recycling-Data">Different Starting Points and Recycling Data</a><a id="Different-Starting-Points-and-Recycling-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Different-Starting-Points-and-Recycling-Data" title="Permalink"></a></h2><p>The method could converge to different points depending on the starting point. We can pass the evaluation data from previous runs to facilitate the construction of surrogate models:</p><pre><code class="language-julia hljs">ac = AlgoConfig( max_iter = 10 ); #hide
mop_rbf = MixedMOP(); #hide
#  define the RBF surogates #hide
rbf_cfg = RbfConfig(  #hide
    kernel = :multiquadric, #hide
    shape_parameter = &quot;20/Œî&quot;  #hide
); #hide
#  add objective functions to `mop_rbf` #hide
add_objective!(mop_rbf, f‚ÇÅ, rbf_cfg ); #hide
add_objective!(mop_rbf, f‚ÇÇ, rbf_cfg ); #hide
#  an array of well spread points in [-4,4]¬≤ #hide
X =[ #hide
 [-4.0, -4.0], #hide
 [3.727327839472812, 3.8615291196035457], #hide
 [3.804712690019901, -3.9610212058521235], #hide
 [-0.14512898384374573, -0.005775390168885508], #hide
 [-3.775315499879552, 3.8150054323309064], #hide
 [1.714228746087743, 1.8435786475209621], #hide
 [-1.9603720505875337, -2.0123206708499275], #hide
 [3.9953803225349187, -0.47734576293976794], #hide
 [-3.9944468955728745, 0.49857343385493635], #hide
 [-1.0455585089057458, 2.735699160002545] #hide
]; #hide

#  Suppose, `X` is a list of different points in ‚Ñù¬≤.

#  A dict to associate starting and end points:
start_fin_points = Dict();

#  perform several runs:
db‚ÇÄ = nothing # initial database can be `nothing`
for x‚ÇÄ ‚àà X
    global db‚ÇÄ
    x_fin, fx_fin, idat = optimize( mop_rbf, x‚ÇÄ; algo_config = ac, populated_db = db‚ÇÄ )
    #  add points to dict
    start_fin_points[x‚ÇÄ] = x_fin
    #  merge databases for recycling
    db‚ÇÄ = Morbit.merge( db‚ÇÄ, Morbit.db(idat) )
end</code></pre><p>Plotting:</p><pre><code class="language-julia hljs">fig, ax, _ = lines( [(-1,-1),(1,1)]; color = :blue, linewidth = 2,
    figure = (resolution = (600, 600), ),
    axis = (title=&quot;Different Starting Points&quot;,),
)

for (k,v) in start_fin_points
    lines!( [ Tuple(k), Tuple(v) ]; color = :lightgray )
end

scatter!( Tuple.(keys(start_fin_points));
    color = :green
)
scatter!( Tuple.(values(start_fin_points));
    color = :lightblue
)

fig #hide</code></pre><p>In the plot, the green points show the starting points and the lightblue circles show the final iterates:</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_logging/">¬´ Debug Info</a><a class="docs-footer-nextpage" href="../example_zdt/">ZDT3 ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 30 July 2021 15:02">Friday 30 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
