<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AbstractDB Interface · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/AbstractDBInterface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../example_zdt/">ZDT3</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../dev_man/">DocStrings</a></li><li><a class="tocitem" href="../Interfaces/">Interfaces</a></li><li><a class="tocitem" href="../AbstractResultInterface/"><code>AbstractResult</code> Interface</a></li><li><a class="tocitem" href="../AbstractIterDataInterface/"><code>AbstractIteraData</code> Interface</a></li><li class="is-active"><a class="tocitem" href><code>AbstractDB</code> Interface</a><ul class="internal"><li><a class="tocitem" href="#Mandatory-Methods"><span>Mandatory Methods</span></a></li><li><a class="tocitem" href="#Derived-methods"><span>Derived methods</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href><code>AbstractDB</code> Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>AbstractDB</code> Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/master/src/AbstractDBInterface.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Database-Interface"><a class="docs-heading-anchor" href="#Database-Interface">Database Interface</a><a id="Database-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Interface" title="Permalink"></a></h1><p>This file describes the methods that should or can be implemented for subtypes of <code>AbstractDB</code>.</p><p>First of all, we make it so that any <code>AbstractResult</code> is broadcasted wholly:</p><pre><code class="language-julia hljs">Broadcast.broadcastable( db :: AbstractDB ) = Ref( db );
nothing #hide</code></pre><h2 id="Mandatory-Methods"><a class="docs-heading-anchor" href="#Mandatory-Methods">Mandatory Methods</a><a id="Mandatory-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Mandatory-Methods" title="Permalink"></a></h2><p>A database should be constructed using the <code>init_db</code> method:</p><pre><code class="language-julia hljs">&quot;Constructor for empty database of type `T`.&quot;
function init_db( :: T, ::Type{ &lt;: AbstractResult },
    :: Type{&lt;:NothingOrSaveable}) :: T where T&lt;:Type{&lt;:AbstractDB}
    nothing
end</code></pre><p>Internally the variables might be scaled (or <em>transformed</em>). The <code>is_transformed</code> method gives an indication to whether or not the site vectors of the stored results are transformed or not. <code>set_transformed!</code> is used to set the flag.</p><pre><code class="language-julia hljs">&quot;Bool indicating if the database data been transformed.&quot;
is_transformed( :: AbstractDB ) :: Bool = false
&quot;Set the flag indicating whether the database data has been transformed or not.&quot;
set_transformed!( :: AbstractDB, :: Bool ) :: Nothing = nothing</code></pre><p>The results are indexed with integers and <code>get_ids</code> should return a vector or iterator of all result ids:</p><pre><code class="language-julia hljs">&quot;List of all `id :: Int` belonging to the stored results.&quot;
get_ids( db :: AbstractDB  ) = Int[]</code></pre><p>An <code>id</code> can then be used to retrieve a result from the database:</p><pre><code class="language-julia hljs">&quot;Get result with `id` from database `db`.&quot;
function get_result( db :: AbstractDB{R,I}, id :: Int ) :: R where {R &lt;: AbstractResult,I}
    return R()
end</code></pre><p>When a new result is added to the database, <code>next_id</code> is called to get its id:</p><pre><code class="language-julia hljs">&quot;Return an id for the next result to be added to `db`.&quot;
function next_id( db :: AbstractDB ) :: Int
	return -1
end

&quot;Add result `res` to database `db`.&quot;
_add_result!(db :: AbstractDB, res :: AbstractResult) = nothing</code></pre><p>There is only one simple method to put an <code>AbstractIterSaveable</code> into a database:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    stamp!(db, ids)

Put the saveable `ids` into the database `db`.
&quot;&quot;&quot;
function stamp!( db :: AbstractDB, ids :: NothingOrSaveable) :: Nothing
	return nothing
end</code></pre><h2 id="Derived-methods"><a class="docs-heading-anchor" href="#Derived-methods">Derived methods</a><a id="Derived-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-methods" title="Permalink"></a></h2><h3 id="Getters"><a class="docs-heading-anchor" href="#Getters">Getters</a><a id="Getters-1"></a><a class="docs-heading-anchor-permalink" href="#Getters" title="Permalink"></a></h3><p>There are getters for the types …</p><pre><code class="language-julia hljs">&quot;Return type of results stored in database.&quot;
get_res_type( :: AbstractDB{R,I} ) where {R,I} = R
&quot;Return type of `AbstractIterSaveable`s stored in database.&quot;
get_saveable_type( :: AbstractDB{R,I}) where {R,I} = I</code></pre><p>… and for the values:</p><pre><code class="language-julia hljs">&quot;Return the evaluation site vector for result with `id` in database `db`.&quot;
get_value( db :: AbstractDB, id :: Int ) = get_value( get_result( db, id ) )
&quot;Return the evaluation value vector for result with `id` in database `db`.&quot;
get_site( db :: AbstractDB, id :: Int ) = get_site( get_result( db, id) )

&quot;Return a vector of all evaluation site vectors stored in database.&quot;
function get_sites( db :: AbstractDB)
	return [ get_site( get_result( db, id ) ) for id = get_ids( db ) ]
end

&quot;Return a vector of all evaluation value vectors stored in database.&quot;
function get_values( db :: AbstractDB  )
	return [ get_value( get_result( db, id ) ) for id = get_ids( db ) ]
end</code></pre><p>For getting the number of results in a database we owerwrite <code>Base.length</code>.</p><pre><code class="language-julia hljs">&quot;Number of entries in database.&quot;
Base.length( db :: AbstractDB ) :: Int = length(get_sites(db))</code></pre><p>There is a default implmentation to get the ids of results in a database that don&#39;t have valid value vectors. I recommend to owerwrite this:</p><pre><code class="language-julia hljs">&quot;Return `true` if the result with `id` in `db` has a valid evaluation vector.&quot;
function get_evaluated_flag( db, id ) :: Bool
    res = get_result(db, id)
    has_valid_value( res ) &amp;&amp; return true
    return false
end

&quot;Return vector of ids of database `db` that are not evaluated yet.&quot;
function _missing_ids( db :: AbstractDB )
    missing_ids = Int[]
    for id = get_ids( db )
        if !get_evaluated_flag(db, id)
            push!(missing_ids, id)
        end
    end
    return _missing_ids
end</code></pre><h3 id="Setters"><a class="docs-heading-anchor" href="#Setters">Setters</a><a id="Setters-1"></a><a class="docs-heading-anchor-permalink" href="#Setters" title="Permalink"></a></h3><p><code>new_result!</code> is meant to construct a new result and return its data base index. It is implemented so that if <code>id</code> is provided as a positive integer, the new result has that id. Else, <code>next_id</code> should be called internally.</p><pre><code class="language-julia hljs">&quot;Add a new result to the database, return its id of type Int.&quot;
function new_result!( db :: AbstractDB{R,I}, x :: Vec, y :: Vec, id :: Int = - 1 ) where{R,I}
    new_id = id &lt; 0 ? next_id(db) : id
	new_result = init_res( R, x, y, new_id )
	push!(db.res, new_result)
	if !has_valid_value(new_result)
		set_evaluated_flag!( db, new_id, false )
	end
	db.num_entries += 1
	return new_id
end</code></pre><p>These setters are used in (un)transforming the database. They are based on the setters for <code>AbstractResult</code>:</p><pre><code class="language-julia hljs">&quot;Set site of result with `id` in database `db` to `x`.&quot;
function set_site!(db, id, x) :: Nothing
    set_site!( get_result(db,id), x )
end

&quot;Set value of result with `id` in database `db` to `x`.&quot;
function set_value!(db, id, y) :: Nothing
    set_value!( get_result(db,id), y )
end</code></pre><p>If you overwrite <code>get_evaluated_flag</code> you might want to overwrite <code>set_evaluated_flag!</code> too:</p><pre><code class="language-julia hljs">&quot;Set the evaluation status for result with `id` to `state`.&quot;
set_evaluated_flag!( db :: AbstractDB, id :: Int, state = true) = nothing</code></pre><h3 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h3><p>To find a result by its values we have:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    find_result(db, x, y)
Return id of a result in `db` that has site `x` and value `y` or return -1
if there is no such result.
&quot;&quot;&quot;
function find_result( db :: AbstractDB, x :: Vec, y :: Vec  ) :: Int
    for id ∈ get_ids( db )
        if get_site( db, id ) == x &amp;&amp; get_value( db, id ) == y
            return id
        end
    end
    return -1
end</code></pre><p>The above function is utilized in <code>ensure_contains_values!</code>:</p><pre><code class="language-julia hljs">&quot;Return id of result in `db` with site `x` and values `y`. Create if necessary.&quot;
function ensure_contains_values!( db :: AbstractDB, x :: Vec, y :: Vec ) :: Int
    x_pos = find_result(db, x,y);
    if x_pos &lt; 0
        x_pos = new_result!(db, x, y);
    end
    return x_pos
end</code></pre><p>The <code>eval_missing</code> method is important for the new two stage model construction process and called after &quot;preparing&quot; the models for updates but before calling the <code>update_model</code> methods:</p><pre><code class="language-julia hljs">&quot;Evaluate all unevaluated results in `db` using objectives of `mop`.&quot;
function eval_missing!( db :: AbstractDB, mop :: AbstractMOP ) :: Nothing

    missing_ids = _missing_ids(db)

    @logmsg loglevel2 &quot;Performing $(length(missing_ids)) objective evaluations into the database.&quot;
    # evaluate everything in one go to exploit parallelism
    eval_sites = [ get_site( db, id ) for id in missing_ids ]
    eval_values = eval_all_objectives.(mop, eval_sites)

    @assert length(eval_sites) == length(eval_values) == length(missing_ids) &quot;Number of evaluation results does not match.&quot;
    for (i,id) in enumerate(missing_ids)
        set_value!( db, id, eval_values[i] )
    end

    for id in missing_ids
        set_evaluated_flag!(db, id)
    end
    return nothing
end</code></pre><p>Internally the variables might be scaled. For conversion we offer the <code>scale!</code> and <code>unscale!</code> defaults:</p><pre><code class="language-julia hljs">&quot;Scale the site of result with `id` in database `db` using bounds of `mop`.&quot;
function scale!( db :: AbstractDB, id :: Int, mop :: AbstractMOP ) :: Nothing
    set_site!( db, id, scale( get_site( db, id ), mop ) )
    return nothing
end

&quot;Unscale the site of result with `id` in database `db` using bounds of `mop`.&quot;
function unscale!( db :: AbstractDB, id :: Int, mop :: AbstractMOP ) :: Nothing
    set_site!( db, id, unscale( get_site( db, id), mop ) )
    return nothing
end</code></pre><p>Also, the value vectors might be resorted internally. This is taken care of by the following methods:</p><pre><code class="language-julia hljs">&quot;Apply internal objective sorting to result with `id` in `db`.&quot;
function apply_internal_sorting!( db :: AbstractDB, id :: Int, mop :: AbstractMOP ) :: Nothing
	set_value!( db, id, apply_internal_sorting( get_value(db, id), mop ) )
    return nothing
end

&quot;Reverse internal sorting of objectives for the result with `id` in `db`.&quot;
function reverse_internal_sorting!( db :: AbstractDB, id :: Int, mop :: AbstractMOP ) :: Nothing
	set_value!( db, id, reverse_internal_sorting( get_value(db, id), mop ) )
    nothing
end</code></pre><p>Both, variable scaling and objective sorting, is combined in the <code>(un)transform!</code> methods:</p><pre><code class="language-julia hljs">&quot;Apply scaling and objectives sorting to each result in database `db`.&quot;
function transform!( db :: AbstractDB, mop :: AbstractMOP ) :: Nothing
    if !is_transformed(db)
        for id in get_ids(db)
            scale!( db, id, mop)
            apply_internal_sorting!( db, id, mop )
        end
        set_transformed!(db, true)
    end
    nothing
end

&quot;Undo scaling and objectives sorting to each result in database `db`.&quot;
function untransform!( db :: AbstractDB, mop :: AbstractMOP ) :: Nothing
    if is_transformed(db)
        for id in get_ids(db)
            unscale!( db, id, mop)
            reverse_internal_sorting!( db, id, mop )
        end
        set_transformed!(db, false)
    end
    nothing
end</code></pre><p>We have a generic copy function that returns a new database containing results from the old database:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    copy_db( old_db, result_type, saveable_type )

Return a new database of same &#39;base&#39; type but possibly with different result and
saveable type.
&quot;&quot;&quot;
function copy_db( old_db :: DBT; res_type = Nothing, saveable_type :: Type = Nothing ) where DBT &lt;: AbstractDB
    try
        base_type = @eval $(DBT.name.name)
        _res_type = res_type &lt;: Nothing ? get_res_type( old_db ) : res_type
        _saveable_type = saveable_type &lt;: Nothing ? get_saveable_type( old_db ) : saveable_type
        new_db = init_db(base_type, _res_type, _saveable_type )
        for id = get_ids(old_db)
            res = get_result( old_db, id )
            new_result!(new_db, get_site(res), get_value(res) )
        end
        @logmsg loglevel2 &quot;Copied database with new saveable type.&quot;
        return new_db
    catch e
        @error &quot;Failed to copy database with new saveable type.&quot; exception=(e, catch_backtrace())
        return old_db
    end
end</code></pre><p>Finally, this little helper returns ids of database results that conform to some variable bounds and is used in the model construction:</p><pre><code class="language-julia hljs">&quot;Return indices of results in `db` that lie in a box with corners `lb` and `ub`.&quot;
function results_in_box_indices(db, lb, ub, exclude_indices = Int[] )
	return [ id for id = get_ids( db ) if
		id ∉ exclude_indices &amp;&amp; all(lb .&lt;= get_site(db,id) .&lt;= ub ) ]
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AbstractIterDataInterface/">« <code>AbstractIteraData</code> Interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 2 September 2021 10:28">Thursday 2 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
