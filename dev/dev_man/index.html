<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DocStrings · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/dev_man/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../example_zdt/">ZDT3</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Internals</span><ul><li class="is-active"><a class="tocitem" href>DocStrings</a></li><li><a class="tocitem" href="../Interfaces/">Interfaces</a></li><li><a class="tocitem" href="../AbstractResultInterface/"><code>AbstractResult</code> Interface</a></li><li><a class="tocitem" href="../AbstractIterDataInterface/"><code>AbstractIteraData</code> Interface</a></li><li><a class="tocitem" href="../AbstractDBInterface/"><code>AbstractDB</code> Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>DocStrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DocStrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/master/docs/src/dev_man.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-Manual"><a class="docs-heading-anchor" href="#Developer-Manual">Developer Manual</a><a id="Developer-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Manual" title="Permalink"></a></h1><p>This page is a big TODO!</p><p>For now, there are only the doc-strings:</p><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractConfig" href="#Morbit.AbstractConfig"><code>Morbit.AbstractConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for user configurable algorithm configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractDB" href="#Morbit.AbstractDB"><code>Morbit.AbstractDB</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract database super type. Implemented by <code>ArrayDB</code> and <code>MockDB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractDescentConfig" href="#Morbit.AbstractDescentConfig"><code>Morbit.AbstractDescentConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for descent step configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractIterData" href="#Morbit.AbstractIterData"><code>Morbit.AbstractIterData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for iteration data. Implemented by <code>IterData</code>.  Has type parameters for the vector type of itaration site, value vector and trust region radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractIterSaveable" href="#Morbit.AbstractIterSaveable"><code>Morbit.AbstractIterSaveable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for some saveable representation of <code>AbstractIterData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractMOP" href="#Morbit.AbstractMOP"><code>Morbit.AbstractMOP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMOP{T}</code></pre><p>Abstract super type for multi-objective optimization problems. <code>T</code> is <code>true</code> if the problem is modifyable and `false elsewise.</p><p>The user should define a <code>MixedMOP&lt;:AbstractMOP{true}</code>, see <a href="@ref"><code>MixedMOP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractObjective" href="#Morbit.AbstractObjective"><code>Morbit.AbstractObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for any kind of (vector) objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractResult" href="#Morbit.AbstractResult"><code>Morbit.AbstractResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for stuff stored in the database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractSurrogateContainer" href="#Morbit.AbstractSurrogateContainer"><code>Morbit.AbstractSurrogateContainer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper around a list of <code>AbstractSurrogateWrapper</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.AbstractSurrogateWrapper" href="#Morbit.AbstractSurrogateWrapper"><code>Morbit.AbstractSurrogateWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type wrapping around an objective, its model and the surrogate meta.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.DiffFn" href="#Morbit.DiffFn"><code>Morbit.DiffFn</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Super type for making (automatic) differentiation comfortable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.ExactConfig" href="#Morbit.ExactConfig"><code>Morbit.ExactConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactConfig(; gradients, jacobian = nothing, max_evals = typemax(Int64))</code></pre><p>Configuration for an <code>ExactModel</code>. <code>gradients</code> should be a vector of callbacks for the objective gradients <strong>or</strong>  a <code>Symbol</code>, either <code>:autodiff</code> or <code>fdm</code>, to define the differentiation method  to use on the objective. Alternatively, a <code>jacobian</code> handle can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.ExactModel" href="#Morbit.ExactModel"><code>Morbit.ExactModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactModel( tfn, objf, diff_fn )</code></pre><p>Exact Model type for evaluating the objective function <code>objf</code> directly. Is instantiated by the corresponding <code>init_model</code> and <code>update_model</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.RbfConfig" href="#Morbit.RbfConfig"><code>Morbit.RbfConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RbfConfig(; kwarg1 = val1, … )</code></pre><p>Configuration type for local RBF surrogate models.</p><p>To choose a kernel, use the kwarg <code>kernel</code> and a value of either  <code>:cubic</code> (default), <code>:inv_multiquadric</code>, <code>:multiquadric</code>, <code>:gaussian</code> or <code>:thin_plate_spline</code>. The kwarg <code>shape_parameter</code> takes a constant number or a string  that defines a calculation on <code>Δ</code>, e.g, &quot;Δ/10&quot;. Note, that <code>shape_parameter</code> has a different meaning for the different kernels. For `<code>:gaussian, :inv_multiquadric, :multiquadric</code> it actually is a floating point shape<em>parameter. For :cubic it is the (odd) integer exponent and for `thin</em>plate_spline<code>it is an integer exponent as well. Use</code>NaN` for defaults.</p><p>To see other configuration parameters use <code>fieldnames(Morbit.RbfConfig)</code>. They have individual docstrings attached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/RbfModel.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.SurrogateConfig" href="#Morbit.SurrogateConfig"><code>Morbit.SurrogateConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for a configuration type defining some surrogate model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.SurrogateMeta" href="#Morbit.SurrogateMeta"><code>Morbit.SurrogateMeta</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for meta data that is used to build a model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.SurrogateModel" href="#Morbit.SurrogateModel"><code>Morbit.SurrogateModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract super type for the actual surrogate models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Interfaces.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorApproximateConfig" href="#Morbit.TaylorApproximateConfig"><code>Morbit.TaylorApproximateConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorApproximateConfig(;degree=1,mode=:fdm,max_evals=typemax(Int64))</code></pre><p>Configure a linear or quadratic Taylor model where the gradients and Hessians are constructed  either by finite differencing (<code>mode = :fdm</code>) or automatic differencing (<code>mode = :autodiff</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L293-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorCallbackConfig" href="#Morbit.TaylorCallbackConfig"><code>Morbit.TaylorCallbackConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorCallbackConfig(;degree=1,gradients,hessians=nothing,max_evals=typemax(Int64))</code></pre><p>Configuration for a linear or quadratic Taylor model where there are callbacks provided for the  gradients and – if applicable – the Hessians. The <code>gradients</code> keyword point to an array of callbacks where each callback evaluates  the gradient of one of the outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L266-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorConfig" href="#Morbit.TaylorConfig"><code>Morbit.TaylorConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorConfig(; degree, gradients :: RFD.CFDStamp, hessians :: RFD.CFDStamp, max_evals)</code></pre><p>Configuration for a polynomial Taylor model using finite difference approximations of the derivatives. By default we have <code>degree = 2</code> and <code>gradients == hessians == RFD.CFDStamp(1,2)</code>, that is,  a first order central difference scheme of accuracy order 3 is recursed to compute the Hessians  and the gradients. In this case, the finite difference scheme is the same for both Hessians and gradients and we profit  from caching intermediate results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TransformerFn" href="#Morbit.TransformerFn"><code>Morbit.TransformerFn</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return the <code>TransformerFn</code> defined by <code>mop</code> with a minimum precision of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TransformerFn-Tuple{AbstractVector{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Real}" href="#Morbit.TransformerFn-Tuple{AbstractVector{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Real}"><code>Morbit.TransformerFn</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unscale the point <code>x̂</code> from internal to original domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Morbit.AbstractDB}" href="#Base.length-Tuple{Morbit.AbstractDB}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of entries in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._add!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective, Union{Nothing, Vector{Int64}}}" href="#Morbit._add!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective, Union{Nothing, Vector{Int64}}}"><code>Morbit._add!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add an objective function to MOP with specified output indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._add_result!-Tuple{Morbit.AbstractDB, Morbit.AbstractResult}" href="#Morbit._add_result!-Tuple{Morbit.AbstractDB, Morbit.AbstractResult}"><code>Morbit._add_result!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add result <code>res</code> to database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._backtrack-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any, Any, Any}} where F&lt;:AbstractFloat" href="#Morbit._backtrack-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any, Any, Any}} where F&lt;:AbstractFloat"><code>Morbit._backtrack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a backtracking loop starting at <code>x</code> with an initial step of <code>step_size .* dir</code> and return trial point <code>x₊</code>, the surrogate value-vector <code>m_x₊</code> and the final step <code>s = x₊ .- x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/descent.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._consume_points-NTuple{7, Any}" href="#Morbit._consume_points-NTuple{7, Any}"><code>Morbit._consume_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_consume_points(data_base, poised_points, poised_indices, candidate_indices)</code></pre><p>Helper to return array of database indices for <code>poised_points</code> and  <code>poised_indices</code>. Add result to database if index is -1. <code>candidate_indices</code> are the database indices of the points from the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/LagrangeModel.jl#L407-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._del!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}" href="#Morbit._del!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}"><code>Morbit._del!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove an objective function from MOP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._equal_vals-Tuple{Morbit.AbstractResult, Morbit.AbstractResult}" href="#Morbit._equal_vals-Tuple{Morbit.AbstractResult, Morbit.AbstractResult}"><code>Morbit._equal_vals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_equal_vals( r1 :: AbstractResult, r2 :: AbstractResult )</code></pre><p>Return <code>true</code> if both the site and the value vectors of <code>r1</code> and <code>r2</code> are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit._eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit._eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate (internal) output <code>ℓ</code> of TaylorModel <code>tm</code>, provided a difference vector <code>h = x - x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_optim_handle-Tuple{Morbit.SurrogateModel, Int64}" href="#Morbit._get_optim_handle-Tuple{Morbit.SurrogateModel, Int64}"><code>Morbit._get_optim_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function handle to be used with <code>NLopt</code> for output <code>ℓ</code> of <code>model</code>. That is, if <code>model</code> is a surrogate for two scalar objectives, then <code>ℓ</code> must  be either 1 or 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/SurrogateModelInterface.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_ps_constraint_func-Tuple{Morbit.SurrogateContainer, Any, Any, Any}" href="#Morbit._get_ps_constraint_func-Tuple{Morbit.SurrogateContainer, Any, Any, Any}"><code>Morbit._get_ps_constraint_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_ps_constraint_func( sc :: SurrogateContainer, mx, dir, l )</code></pre><p>Return the <code>l</code>-th (possibly non-linear) constraint function  for Pascoletti-Serafini. <code>dir</code> .&gt;= 0 is the image direction; <code>χ = [t;x]</code> is the augmented variable vector;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/descent.jl#L350-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_ps_objective_func-Tuple{}" href="#Morbit._get_ps_objective_func-Tuple{}"><code>Morbit._get_ps_objective_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return objective function for Pascoletti-Serafini, modifying gradient in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/descent.jl#L370-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._init_model-Tuple{ExactConfig, Morbit.AbstractObjective, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig, Morbit.ExactMeta}" href="#Morbit._init_model-Tuple{ExactConfig, Morbit.AbstractObjective, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig, Morbit.ExactMeta}"><code>Morbit._init_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return an ExactModel build from a VectorObjectiveFunction <code>objf</code>.  Model is the same inside and outside of criticality round.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._intersect_bounds-NTuple{4, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._intersect_bounds-NTuple{4, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._intersect_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return smallest positive and biggest negative and <code>σ₊</code> and <code>σ₋</code> so that <code>x .+ σ± .* d</code> stays within bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._local_bounds-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._local_bounds-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._local_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return lower and upper bound vectors combining global and trust region constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._missing_ids-Tuple{Morbit.AbstractDB}" href="#Morbit._missing_ids-Tuple{Morbit.AbstractDB}"><code>Morbit._missing_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return vector of ids of database <code>db</code> that are not evaluated yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._objf_index-Tuple{Morbit.AbstractObjective, Morbit.AbstractMOP}" href="#Morbit._objf_index-Tuple{Morbit.AbstractObjective, Morbit.AbstractMOP}"><code>Morbit._objf_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Position of <code>objf</code> in <code>list_of_objectives(mop)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._output_model_mapping-Tuple{Morbit.AbstractSurrogateContainer, Int64}" href="#Morbit._output_model_mapping-Tuple{Morbit.AbstractSurrogateContainer, Int64}"><code>Morbit._output_model_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_output_model_mapping(sc, l)</code></pre><p>Return a <code>Tuple{Int,Int}</code> with the index <code>i</code> of the surrogate model and its output <code>k</code> describing output <code>l</code> of an MOP with scalarized outputs <code>1:l</code>.</p><p><strong>Example</strong></p><p>Suppose an MOP is setup with the 3 scalar objectives f1, f2 and f3 and  there is one surrogate model modelling f1 and f3 (in that order) and  a second model for f2. <code>sc</code> holds the surrogates in that order. Then:</p><pre><code class="language-julia_repl hljs">julia&gt; _output_model_mapping(sc,1)
(1,1)
julia&gt; _output_model_mapping(sc,2)
(2,1)
julia&gt; _output_model_mapping(sc,3)
(1,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L36-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._ps_optimization-Union{Tuple{F}, Tuple{Morbit.SurrogateContainer, Symbol, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, AbstractVector{F}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, Int64}} where F" href="#Morbit._ps_optimization-Union{Tuple{F}, Tuple{Morbit.SurrogateContainer, Symbol, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, AbstractVector{F}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, Int64}} where F"><code>Morbit._ps_optimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct and solve Pascoletti Serafini subproblem using surrogates from <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/descent.jl#L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._sc_output_model_mapping-Tuple{Morbit.AbstractSurrogateContainer, Int64}" href="#Morbit._sc_output_model_mapping-Tuple{Morbit.AbstractSurrogateContainer, Int64}"><code>Morbit._sc_output_model_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_sc_output_model_mapping(sc, ℓ)</code></pre><p>Return a <code>Tuple{Int,Int}</code> with the index <code>i</code> of the surrogate model and its output <code>k</code> describing output <code>ℓ</code> of <code>sc</code>, i.e., as returned by <code>eval_models(sc, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._set_delta!-Tuple{Morbit.AbstractIterData, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}" href="#Morbit._set_delta!-Tuple{Morbit.AbstractIterData, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}"><code>Morbit._set_delta!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set current trust region radius (vector?) to <code>Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._set_fx!-Tuple{Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._set_fx!-Tuple{Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._set_fx!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set current iteration value vector to <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._set_x!-Tuple{Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._set_x!-Tuple{Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._set_x!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set current iteration site to <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._steepest_descent_direction-Union{Tuple{F}, Tuple{AbstractVector{F}, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}} where F&lt;:AbstractFloat" href="#Morbit._steepest_descent_direction-Union{Tuple{F}, Tuple{AbstractVector{F}, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}} where F&lt;:AbstractFloat"><code>Morbit._steepest_descent_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provided <code>x</code> and the (surrogate) jacobian <code>∇F</code> at <code>x</code>, as well as bounds <code>lb</code> and <code>ub</code>, return steepest multi descent direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/descent.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._wrap_func-Union{Tuple{O}, Tuple{T}, Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.OutTypeWrapper{T, O}, Function, Morbit.SurrogateConfig, Int64, Int64}} where {T, O}" href="#Morbit._wrap_func-Union{Tuple{O}, Tuple{T}, Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.OutTypeWrapper{T, O}, Function, Morbit.SurrogateConfig, Int64, Int64}} where {T, O}"><code>Morbit._wrap_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A general constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._wrap_func-Union{Tuple{T}, Tuple{T, Function, Morbit.SurrogateConfig, Int64, Int64}} where T&lt;:(Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.AbstractObjective)" href="#Morbit._wrap_func-Union{Tuple{T}, Tuple{T, Function, Morbit.SurrogateConfig, Int64, Int64}} where T&lt;:(Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.AbstractObjective)"><code>Morbit._wrap_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A general constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!" href="#Morbit.add_objective!"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_objective!( mop :: MixedMOP, func :: T where{T &lt;: Function}, type :: Symbol = :expensive, n_out :: Int64 = 1, can_batch :: Bool = false )</code></pre><p>Add scalar-valued objective function <code>func</code> to <code>mop</code> structure. <code>func</code> must take an <code>Vec</code> as its (first) argument, i.e. represent a function <span>$f: ℝ^n → ℝ$</span>. <code>type</code> must either be <code>:expensive</code> or <code>:cheap</code> to determine whether the function is replaced by a surrogate model or not.</p><p>If <code>type</code> is <code>:cheap</code> and <code>func</code> takes 1 argument only then its gradient is calculated by ForwardDiff. A cheap function <code>func</code> with custom gradient function <code>grad</code> (representing <span>$∇f : ℝ^n → ℝ^n$</span>) is added by</p><pre><code class="nohighlight hljs">add_objective!(mop, func, grad)</code></pre><p>The optional argument <code>n_out</code> allows for the specification of vector-valued objective functions. This is mainly meant to be used for <em>expensive</em> functions that are in some sense inter-dependent.</p><p>The flag <code>can_batch</code> defaults to false so that the objective function is simply looped over a bunch of arguments if required. If <code>can_batch == true</code> then the objective function must be able to return an array of results when provided an array of input vectors (whilst still returning a single result, not a singleton array containing the result, for a single input vector).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># Define 2 scalar objective functions and a MOP ℝ^2 → ℝ^2

f1(x) =  x[1]^2 + x[2]

f2(x) = exp(sum(x))
∇f2(x) = exp(sum(x)) .* ones(2);

mop = MixedMOP()
add_objective!(mop, f1, :cheap)     # gradient will be calculated using ForwardDiff
add_objective!(mop, f2, ∇f2 )       # gradient is provided</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/adding_objectives.jl#L23-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!-Tuple{MixedMOP, Function, Function}" href="#Morbit.add_objective!-Tuple{MixedMOP, Function, Function}"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_objective!( mop :: MixedMOP, func :: T where{T &lt;: Function}, grad :: T where{T &lt;: Function})</code></pre><p>Add scalar-valued objective function <code>func</code> and its vector-valued gradient <code>grad</code> to <code>mop</code> struture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/adding_objectives.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}" href="#Morbit.add_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a scalar objective to <code>mop::MixedMOP</code> modelled according to <code>model_config</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/adding_objectives.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_vector_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}" href="#Morbit.add_vector_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}"><code>Morbit.add_vector_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a vector objective to <code>mop::MixedMOP</code> modelled according to <code>model_config</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/adding_objectives.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.apply_internal_sorting!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}" href="#Morbit.apply_internal_sorting!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}"><code>Morbit.apply_internal_sorting!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply internal objective sorting to result with <code>id</code> in <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.combine-Union{Tuple{F}, Tuple{T}, Tuple{T, F}} where {T&lt;:Morbit.AbstractObjective, F&lt;:Morbit.AbstractObjective}" href="#Morbit.combine-Union{Tuple{F}, Tuple{T}, Tuple{T, F}} where {T&lt;:Morbit.AbstractObjective, F&lt;:Morbit.AbstractObjective}"><code>Morbit.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine two objectives. Only needed if <code>combinable</code> can return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.combine-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F&lt;:Function, T&lt;:Function}" href="#Morbit.combine-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F&lt;:Function, T&lt;:Function}"><code>Morbit.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a new function function handle stacking the output of <code>func1</code> and <code>func2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/BatchObjectiveFunction.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.copy_db-Tuple{DBT} where DBT&lt;:Morbit.AbstractDB" href="#Morbit.copy_db-Tuple{DBT} where DBT&lt;:Morbit.AbstractDB"><code>Morbit.copy_db</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_db( old_db, result_type, saveable_type )</code></pre><p>Return a new database of same &#39;base&#39; type but possibly with different result and saveable type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.ensure_contains_values!-Tuple{Morbit.AbstractDB, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.ensure_contains_values!-Tuple{Morbit.AbstractDB, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.ensure_contains_values!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return id of result in <code>db</code> with site <code>x</code> and values <code>y</code>. Create if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_all_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_all_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_all_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(Internally) Evaluate all objectives at site <code>x̂::Vec</code>. Objective order might differ from order in which they were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_and_sort_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_and_sort_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_and_sort_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate all objectives at site <code>x̂::Vec</code> and sort the result according to the order in which objectives were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_handle-Tuple{Morbit.AbstractObjective}" href="#Morbit.eval_handle-Tuple{Morbit.AbstractObjective}"><code>Morbit.eval_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function that evaluates an objective at an <strong>unscaled</strong> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_missing!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}" href="#Morbit.eval_missing!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}"><code>Morbit.eval_missing!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate all unevaluated results in <code>db</code> using objectives of <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_models( sc, x̂, l )</code></pre><p>Return model value for output <code>l</code> of <code>sc</code> at <code>x̂</code>. Index <code>l</code> is assumed to be an <em>internal</em> index in the range of 1,…,n<em>objfs, where n</em>objfs is the total number of (scalarized) objectives stored in <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_models-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate all surrogate models stored in <code>sc</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate output <code>ℓ</code> of the ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate (internal) output <code>ℓ</code> of <code>tm</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate output <code>ℓ</code> of <code>mod::RbfModel</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/RbfModel.jl#L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>mod::RbfModel</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/RbfModel.jl#L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_objf-Tuple{Morbit.AbstractObjective, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_objf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the objective at unscaled site <code>x</code>. and increase counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_objf-Tuple{Morbit.AbstractObjective, Morbit.TransformerFn, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, Morbit.TransformerFn, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_objf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the objective at scaled site <code>x̂</code> with help of <code>tfn</code>. Used in <code>diff_wrappers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.find_result-Tuple{Morbit.AbstractDB, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.find_result-Tuple{Morbit.AbstractDB, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.find_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_result(db, x, y)</code></pre><p>Return id of a result in <code>db</code> that has site <code>x</code> and value <code>y</code> or return -1  if there is no such result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_lower_bounds-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_lower_bounds-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_lower_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return full vector of lower variable vectors for original problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_lower_bounds_internal-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_lower_bounds_internal-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_lower_bounds_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return lower variable bounds for scaled variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_upper_bounds-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_upper_bounds-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_upper_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return full vector of upper variable vectors for original problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_upper_bounds_internal-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_upper_bounds_internal-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_upper_bounds_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return upper variable bounds for scaled variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_delta-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}" href="#Morbit.get_delta-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}"><code>Morbit.get_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return current trust region radius (vector) <span>$Δᵗ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_evaluated_flag-Tuple{Any, Any}" href="#Morbit.get_evaluated_flag-Tuple{Any, Any}"><code>Morbit.get_evaluated_flag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return <code>true</code> if the result with <code>id</code> in <code>db</code> has a valid evaluation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_fx-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}" href="#Morbit.get_fx-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}"><code>Morbit.get_fx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return current value vector <span>$f(xᵗ)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_gradient( sc, x̂, l )</code></pre><p>Return a gradient for output <code>l</code> of <code>sc</code> at <code>x̂</code>. Index <code>l</code> is assumed to be an internal index in the range of 1,…,n<em>objfs, where n</em>objfs is the total number of (scalarized) objectives stored in <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gradient vector of output <code>ℓ</code> of <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gradient vector of output <code>ℓ</code> of <code>mod</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/RbfModel.jl#L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_id-Tuple{Morbit.AbstractResult}" href="#Morbit.get_id-Tuple{Morbit.AbstractResult}"><code>Morbit.get_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_id( res :: AbstractResult ) :: Int</code></pre><p>Return the <code>id</code> of a result such that for the database <code>db</code>  containing <code>res</code> it holds that <code>get_result(db, id) == res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_ids-Tuple{Morbit.AbstractDB}" href="#Morbit.get_ids-Tuple{Morbit.AbstractDB}"><code>Morbit.get_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><p>List of all <code>id :: Int</code> belonging to the stored results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_jacobian-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.get_jacobian-Tuple{Morbit.AbstractSurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.get_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate Jacobian of surrogate models stored in <code>sc</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_jacobian-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.get_jacobian-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.get_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jacobian Matrix of ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/ExactModel.jl#L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_jacobian-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.get_jacobian-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.get_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jacobian Matrix of ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/RbfModel.jl#L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_num_iterations-Tuple{Morbit.AbstractIterData}" href="#Morbit.get_num_iterations-Tuple{Morbit.AbstractIterData}"><code>Morbit.get_num_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return number of iterations so far.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_num_model_improvements-Tuple{Morbit.AbstractIterData}" href="#Morbit.get_num_model_improvements-Tuple{Morbit.AbstractIterData}"><code>Morbit.get_num_model_improvements</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of model improvement iterations so far.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_optim_handle-Tuple{Morbit.AbstractSurrogateContainer, Int64}" href="#Morbit.get_optim_handle-Tuple{Morbit.AbstractSurrogateContainer, Int64}"><code>Morbit.get_optim_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function handle to be used with <code>NLopt</code> for output <code>l</code> of <code>sc</code>. Index <code>l</code> is assumed to be an <em>internal</em> index in the range of <code>1, …, n_objfs</code>, where <code>n_objfs</code> is the total number of (scalarized) objectives modelled by <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractSurrogateContainerInterface.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_poised_set-Union{Tuple{Any}, Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s164&quot;, N} where {var&quot;#s164&quot;&lt;:Real, N})" href="#Morbit.get_poised_set-Union{Tuple{Any}, Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s164&quot;, N} where {var&quot;#s164&quot;&lt;:Real, N})"><code>Morbit.get_poised_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )</code></pre><p>Compute a point set suited for polynomial interpolation.</p><p>Input:</p><ul><li><code>basis</code>: A vector of polynomials constituting a basis for the polynomial space.</li><li><code>points</code>: (optional) A set of candidate points to be tried for inclusion into the poised set.</li><li><code>solver</code>: NLopt solver to use. Should be derivative-free.</li><li><code>max_solver_evals</code>: Maximum number of evaluations in each optimization run. </li></ul><p>Return:</p><ul><li><code>poised_points :: Vector{T}</code> where <code>T</code> is either a <code>Vector{F}</code> or an <code>SVector{n_vars, F}</code> and <code>F</code> is the precision of the points in <code>points</code>, but at least <code>Float32</code>. </li><li><code>lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}</code>: The Lagrange basis corresponding to <code>poised_points</code>.</li><li><code>point_indices</code>: An array indicating which points from <code>points</code> are also in <code>poised_points</code>. A positive entry corresponds to the index of a poised point in <code>points</code>. If a poised point is new, then the entry is <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/LagrangeModel.jl#L171-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_res_type-Union{Tuple{Morbit.AbstractDB{R, I}}, Tuple{I}, Tuple{R}} where {R, I}" href="#Morbit.get_res_type-Union{Tuple{Morbit.AbstractDB{R, I}}, Tuple{I}, Tuple{R}} where {R, I}"><code>Morbit.get_res_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return type of results stored in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_result-Union{Tuple{I}, Tuple{R}, Tuple{Morbit.AbstractDB{R, I}, Int64}} where {R&lt;:Morbit.AbstractResult, I}" href="#Morbit.get_result-Union{Tuple{I}, Tuple{R}, Tuple{Morbit.AbstractDB{R, I}, Int64}} where {R&lt;:Morbit.AbstractResult, I}"><code>Morbit.get_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get result with <code>id</code> from database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_saveable_type-Union{Tuple{Morbit.AbstractDB{R, I}}, Tuple{I}, Tuple{R}} where {R, I}" href="#Morbit.get_saveable_type-Union{Tuple{Morbit.AbstractDB{R, I}}, Tuple{I}, Tuple{R}} where {R, I}"><code>Morbit.get_saveable_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return type of <code>AbstractIterSaveable</code>s stored in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_scaling_poly-Tuple{Any, Any, Any}" href="#Morbit.get_scaling_poly-Tuple{Any, Any, Any}"><code>Morbit.get_scaling_poly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return vector of polynomials that scales variables from [lb, ub] to [0,1]^n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/LagrangeModel.jl#L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_site-Tuple{Morbit.AbstractDB, Int64}" href="#Morbit.get_site-Tuple{Morbit.AbstractDB, Int64}"><code>Morbit.get_site</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the evaluation value vector for result with <code>id</code> in database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_site-Union{Tuple{Morbit.AbstractResult{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#Morbit.get_site-Union{Tuple{Morbit.AbstractResult{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>Morbit.get_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_site( res :: AbstractResult{XT,YT} )</code></pre><p>Return evaluation site of type <code>XT</code> associated with <code>res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_sites-Tuple{Morbit.AbstractDB}" href="#Morbit.get_sites-Tuple{Morbit.AbstractDB}"><code>Morbit.get_sites</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a vector of all evaluation site vectors stored in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_unscaling_poly-Tuple{Any, Any, Any}" href="#Morbit.get_unscaling_poly-Tuple{Any, Any, Any}"><code>Morbit.get_unscaling_poly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return vector of polynomials that unscales variables from [0,1]^n to [lb,ub].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/LagrangeModel.jl#L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_value-Tuple{Morbit.AbstractDB, Int64}" href="#Morbit.get_value-Tuple{Morbit.AbstractDB, Int64}"><code>Morbit.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the evaluation site vector for result with <code>id</code> in database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_value-Union{Tuple{Morbit.AbstractResult{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}" href="#Morbit.get_value-Union{Tuple{Morbit.AbstractResult{XT, YT}}, Tuple{YT}, Tuple{XT}} where {XT, YT}"><code>Morbit.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_value( res :: AbstractResult{XT,YT} )</code></pre><p>Return evaluation value vector of type <code>YT</code> associated with <code>res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_values-Tuple{Morbit.AbstractDB}" href="#Morbit.get_values-Tuple{Morbit.AbstractDB}"><code>Morbit.get_values</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a vector of all evaluation value vectors stored in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_x-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}" href="#Morbit.get_x-Union{Tuple{Morbit.AbstractIterData{XT, YT, DT}}, Tuple{DT}, Tuple{YT}, Tuple{XT}} where {XT, YT, DT}"><code>Morbit.get_x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return current iteration site vector <span>$xᵗ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_x_index-Tuple{Morbit.AbstractIterData}" href="#Morbit.get_x_index-Tuple{Morbit.AbstractIterData}"><code>Morbit.get_x_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Index (or <code>id</code>) of current iterate in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.grow_radius-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.grow_radius-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.grow_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grow radius according to <code>min( Δ_max, γ * Δ )</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.grow_radius-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.grow_radius-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.grow_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grow radius according to <code>min( Δ_max, (γ + ||s||/Δ) * Δ )</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.has_valid_site-Tuple{Morbit.AbstractResult}" href="#Morbit.has_valid_site-Tuple{Morbit.AbstractResult}"><code>Morbit.has_valid_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_valid_site( r :: AbstractResult )</code></pre><p>Return <code>true</code> if the site vector of <code>r</code> is neither empty nor NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.has_valid_value-Tuple{Morbit.AbstractResult}" href="#Morbit.has_valid_value-Tuple{Morbit.AbstractResult}"><code>Morbit.has_valid_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_valid_value( r :: AbstractResult )</code></pre><p>Return <code>true</code> if the value vector of <code>r</code> is neither empty nor NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.inc_evals!" href="#Morbit.inc_evals!"><code>Morbit.inc_evals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Increase evaluation count by <code>N</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.inc_num_iterations!" href="#Morbit.inc_num_iterations!"><code>Morbit.inc_num_iterations!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Increase the iteration counter by <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.inc_num_model_improvements!" href="#Morbit.inc_num_model_improvements!"><code>Morbit.inc_num_model_improvements!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Increase the model improvement counter by <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_db-Union{Tuple{T}, Tuple{T, Type{var&quot;#s44&quot;} where var&quot;#s44&quot;&lt;:Morbit.AbstractResult, Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Union{Nothing, Morbit.AbstractIterSaveable}}} where T&lt;:(Type{var&quot;#s71&quot;} where var&quot;#s71&quot;&lt;:Morbit.AbstractDB)" href="#Morbit.init_db-Union{Tuple{T}, Tuple{T, Type{var&quot;#s44&quot;} where var&quot;#s44&quot;&lt;:Morbit.AbstractResult, Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Union{Nothing, Morbit.AbstractIterSaveable}}} where T&lt;:(Type{var&quot;#s71&quot;} where var&quot;#s71&quot;&lt;:Morbit.AbstractDB)"><code>Morbit.init_db</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructor for empty database of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_iter_data-Tuple{Type{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}" href="#Morbit.init_iter_data-Tuple{Type{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Morbit.AbstractIterData, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}"><code>Morbit.init_iter_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_iter_data( T , x, fx, Δ )</code></pre><p>Return an instance of &quot;base&quot; type <code>T</code> implementing <code>AbstractIterData</code> with  correct type parameters for <code>x</code>, <code>fx</code> and <code>Δ</code>. <code>x</code> and <code>fx</code> should be vectors of floats and <code>Δ</code> can either be a float or  a vector of floats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_res-Tuple{Type{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Morbit.AbstractResult, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.init_res-Tuple{Type{var&quot;#s73&quot;} where var&quot;#s73&quot;&lt;:Morbit.AbstractResult, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.init_res</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_res( res_type, x, y, id)</code></pre><p>Return of result of type <code>res_type</code> with site <code>x</code>, value <code>y</code> and database id <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractResultInterface.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_surrogates-Tuple{Type{var&quot;#s165&quot;} where var&quot;#s165&quot;&lt;:Morbit.SurrogateContainer, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig}" href="#Morbit.init_surrogates-Tuple{Type{var&quot;#s165&quot;} where var&quot;#s165&quot;&lt;:Morbit.SurrogateContainer, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig}"><code>Morbit.init_surrogates</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a SurrogateContainer initialized from the information provided in <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/SurrogatesImplementation.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.is_transformed-Tuple{Morbit.AbstractDB}" href="#Morbit.is_transformed-Tuple{Morbit.AbstractDB}"><code>Morbit.is_transformed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bool indicating if the database data been transformed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.it_stat!-Tuple{Morbit.AbstractIterData, Morbit.ITER_TYPE}" href="#Morbit.it_stat!-Tuple{Morbit.AbstractIterData, Morbit.ITER_TYPE}"><code>Morbit.it_stat!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the iteration classification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.it_stat-Tuple{Morbit.AbstractIterData}" href="#Morbit.it_stat-Tuple{Morbit.AbstractIterData}"><code>Morbit.it_stat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the iteration classification of <code>ITER_TYPE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.list_of_objectives-Tuple{Morbit.AbstractMOP}" href="#Morbit.list_of_objectives-Tuple{Morbit.AbstractMOP}"><code>Morbit.list_of_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a list of <code>AbstractVectorObjective</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.local_bounds-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}" href="#Morbit.local_bounds-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}"><code>Morbit.local_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local bounds vectors <code>lb_eff</code> and <code>ub_eff</code> using scaled variable constraints from <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.make_set_lambda_poised-Union{Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s164&quot;, N} where {var&quot;#s164&quot;&lt;:Real, N})" href="#Morbit.make_set_lambda_poised-Union{Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s164&quot;, N} where {var&quot;#s164&quot;&lt;:Real, N})"><code>Morbit.make_set_lambda_poised</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_set_lambda_poised( basis, points; 
    LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )</code></pre><p>Make the output of <code>get_poised_set</code> even better suited for interpolation.</p><p>Input:</p><ul><li><code>basis</code>: A vector of polynomials constituting a Lagrange basis for the polynomial space.</li><li><code>points</code>: The vector of points belonging to the Lagrange basis.</li><li><code>LAMBDA :: Real &gt; 1</code>: Determines the quality of the interpolation. </li><li><code>solver</code>: NLopt solver to use. Should be derivative-free.</li><li><code>max_solver_evals</code>: Maximum number of evaluations in each optimization run. </li><li><code>max_loops</code>: Maximum number of loops that try to make the set Λ-poised.</li><li><code>skip_indices</code>: Inidices of points to discard last.</li></ul><p>Return:</p><ul><li><code>poised_points :: Vector{T}</code> where <code>T</code> is either a <code>Vector{F}</code> or an <code>SVector{n_vars, F}</code> and <code>F</code> is the precision of the points in <code>points</code>, but at least <code>Float32</code>. </li><li><code>lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}</code>: The Lagrange basis corresponding to <code>poised_points</code>.</li><li><code>point_indices</code>: An array indicating which points from <code>points</code> are also in <code>poised_points</code>. A positive entry corresponds to the index of a poised point in <code>points</code>. If a poised point is new, then the entry is <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/LagrangeModel.jl#L260-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.max_evals-Tuple{Morbit.AbstractObjective}" href="#Morbit.max_evals-Tuple{Morbit.AbstractObjective}"><code>Morbit.max_evals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(Soft) upper bound on the number of function calls. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.new_result!-Union{Tuple{I}, Tuple{R}, Tuple{Morbit.AbstractDB{R, I}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, Tuple{Morbit.AbstractDB{R, I}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}} where {R, I}" href="#Morbit.new_result!-Union{Tuple{I}, Tuple{R}, Tuple{Morbit.AbstractDB{R, I}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, Tuple{Morbit.AbstractDB{R, I}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}} where {R, I}"><code>Morbit.new_result!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new result to the database, return its id of type Int.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.next_id-Tuple{Morbit.AbstractDB}" href="#Morbit.next_id-Tuple{Morbit.AbstractDB}"><code>Morbit.next_id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return an id for the next result to be added to <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_evals!-Tuple{Morbit.AbstractObjective, Int64}" href="#Morbit.num_evals!-Tuple{Morbit.AbstractObjective, Int64}"><code>Morbit.num_evals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set evaluation counter to <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_evals-Tuple{Morbit.AbstractObjective}" href="#Morbit.num_evals-Tuple{Morbit.AbstractObjective}"><code>Morbit.num_evals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of calls to the original objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractObjectiveInterface.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_objectives-Tuple{Morbit.AbstractMOP}" href="#Morbit.num_objectives-Tuple{Morbit.AbstractMOP}"><code>Morbit.num_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of scalar-valued objectives of the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.pop_objf!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}" href="#Morbit.pop_objf!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}"><code>Morbit.pop_objf!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove <code>objf</code> from <code>list_of_objectives(mop)</code> and return its output indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reset_evals!-Tuple{Morbit.AbstractMOP}" href="#Morbit.reset_evals!-Tuple{Morbit.AbstractMOP}"><code>Morbit.reset_evals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set evaluation counter to 0 for each VectorObjectiveFunction in <code>m.vector_of_objectives</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.results_in_box_indices" href="#Morbit.results_in_box_indices"><code>Morbit.results_in_box_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return indices of results in <code>db</code> that lie in a box with corners <code>lb</code> and <code>ub</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reverse_internal_sorting!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}" href="#Morbit.reverse_internal_sorting!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}"><code>Morbit.reverse_internal_sorting!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reverse internal sorting of objectives for the result with <code>id</code> in <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reverse_internal_sorting-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.reverse_internal_sorting-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.reverse_internal_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort an interal objective vector so that the objectives are in the order in which they were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reverse_internal_sorting_indices-Tuple{Morbit.AbstractMOP}" href="#Morbit.reverse_internal_sorting_indices-Tuple{Morbit.AbstractMOP}"><code>Morbit.reverse_internal_sorting_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return index vector so that an internal objective vector is sorted according to the order the objectives where added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.scale!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}" href="#Morbit.scale!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}"><code>Morbit.scale!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Scale the site of result with <code>id</code> in database <code>db</code> using bounds of <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.scale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.scale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Scale variables fully constrained to a closed interval to [0,1] internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_evaluated_flag!" href="#Morbit.set_evaluated_flag!"><code>Morbit.set_evaluated_flag!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set the evaluation status for result with <code>id</code> to <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_num_iterations!" href="#Morbit.set_num_iterations!"><code>Morbit.set_num_iterations!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set the iteration counter to <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_num_model_improvements!" href="#Morbit.set_num_model_improvements!"><code>Morbit.set_num_model_improvements!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set the improvement counter to <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_site!-Tuple{Any, Any, Any}" href="#Morbit.set_site!-Tuple{Any, Any, Any}"><code>Morbit.set_site!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set site of result with <code>id</code> in database <code>db</code> to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_transformed!-Tuple{Morbit.AbstractDB, Bool}" href="#Morbit.set_transformed!-Tuple{Morbit.AbstractDB, Bool}"><code>Morbit.set_transformed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the flag indicating whether the database data has been transformed or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_value!-Tuple{Any, Any, Any}" href="#Morbit.set_value!-Tuple{Any, Any, Any}"><code>Morbit.set_value!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set value of result with <code>id</code> in database <code>db</code> to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_x_index!-Tuple{Morbit.AbstractIterData, Int64}" href="#Morbit.set_x_index!-Tuple{Morbit.AbstractIterData, Int64}"><code>Morbit.set_x_index!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the current iteration database id to <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractIterDataInterface.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.shrink_radius-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.shrink_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.shrink_radius-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.shrink_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * ||s||</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius_much-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.shrink_radius_much-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.shrink_radius_much</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius much according to <code>γ * Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius_much-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.shrink_radius_much-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.shrink_radius_much</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * ||s||</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/Morbit.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.stamp!-Tuple{Morbit.AbstractDB, Union{Nothing, Morbit.AbstractIterSaveable}}" href="#Morbit.stamp!-Tuple{Morbit.AbstractDB, Union{Nothing, Morbit.AbstractIterSaveable}}"><code>Morbit.stamp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stamp!(db, ids)</code></pre><p>Put the saveable <code>ids</code> into the database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.transform!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}" href="#Morbit.transform!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}"><code>Morbit.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply scaling and objectives sorting to each result in database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.unique_with_indices-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#Morbit.unique_with_indices-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Morbit.unique_with_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return <code>unique_elems, indices = unique_with_indices(arr)</code> such that  <code>unique_elems[indices] == arr</code> (and <code>unique_elems == unique(arr)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/TaylorModel.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.unscale!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}" href="#Morbit.unscale!-Tuple{Morbit.AbstractDB, Int64, Morbit.AbstractMOP}"><code>Morbit.unscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unscale the site of result with <code>id</code> in database <code>db</code> using bounds of <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.unscale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.unscale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.unscale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reverse scaling for fully constrained variables from [0,1] to their former domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractMOPInterface.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.untransform!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}" href="#Morbit.untransform!-Tuple{Morbit.AbstractDB, Morbit.AbstractMOP}"><code>Morbit.untransform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Undo scaling and objectives sorting to each result in database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/ab7415cf9c2214a4b4e6478ea9e08fa0f7ed8115/src/AbstractDBInterface.jl#L241">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_logging/">« Pretty Printing</a><a class="docs-footer-nextpage" href="../Interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 13:20">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
