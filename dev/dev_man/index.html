<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/dev_man/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../example_zdt/">ZDT3</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/master/docs/src/dev_man.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-Manual"><a class="docs-heading-anchor" href="#Developer-Manual">Developer Manual</a><a id="Developer-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Manual" title="Permalink"></a></h1><p>This page is a big TODO!</p><p>For now, there are only the doc-strings:</p><article class="docstring"><header><a class="docstring-binding" id="Morbit.ExactConfig" href="#Morbit.ExactConfig"><code>Morbit.ExactConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactConfig(; gradients, jacobian = nothing, max_evals = typemax(Int64))</code></pre><p>Configuration for an <code>ExactModel</code>. <code>gradients</code> should be a vector of callbacks for the objective gradients <strong>or</strong>  a <code>Symbol</code>, either <code>:autodiff</code> or <code>fdm</code>, to define the differentiation method  to use on the objective. Alternatively, a <code>jacobian</code> handle can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.ExactModel" href="#Morbit.ExactModel"><code>Morbit.ExactModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactModel( tfn, objf, diff_fn )</code></pre><p>Exact Model type for evaluating the objective function <code>objf</code> directly. Is instantiated by the corresponding <code>init_model</code> and <code>update_model</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.RbfConfig" href="#Morbit.RbfConfig"><code>Morbit.RbfConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RbfConfig(; kwarg1 = val1, … )</code></pre><p>Configuration type for local RBF surrogate models.</p><p>To choose a kernel, use the kwarg <code>kernel</code> and a value of either  <code>:cubic</code> (default), <code>:inv_multiquadric</code>, <code>:multiquadric</code>, <code>:gaussian</code> or <code>:thin_plate_spline</code>. The kwarg <code>shape_parameter</code> takes a constant number or a string  that defines a calculation on <code>Δ</code>, e.g, &quot;Δ/10&quot;. Note, that <code>shape_parameter</code> has a different meaning for the different kernels. For `<code>:gaussian, :inv_multiquadric, :multiquadric</code> it actually is a floating point shape<em>parameter. For :cubic it is the (odd) integer exponent and for `thin</em>plate_spline<code>it is an integer exponent as well. Use</code>NaN` for defaults.</p><p>To see other configuration parameters use <code>fieldnames(Morbit.RbfConfig)</code>. They have individual docstrings attached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/RbfModel.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorApproximateConfig" href="#Morbit.TaylorApproximateConfig"><code>Morbit.TaylorApproximateConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorApproximateConfig(;degree=1,mode=:fdm,max_evals=typemax(Int64))</code></pre><p>Configure a linear or quadratic Taylor model where the gradients and Hessians are constructed  either by finite differencing (<code>mode = :fdm</code>) or automatic differencing (<code>mode = :autodiff</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L293-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorCallbackConfig" href="#Morbit.TaylorCallbackConfig"><code>Morbit.TaylorCallbackConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorCallbackConfig(;degree=1,gradients,hessians=nothing,max_evals=typemax(Int64))</code></pre><p>Configuration for a linear or quadratic Taylor model where there are callbacks provided for the  gradients and – if applicable – the Hessians. The <code>gradients</code> keyword point to an array of callbacks where each callback evaluates  the gradient of one of the outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L266-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TaylorConfig" href="#Morbit.TaylorConfig"><code>Morbit.TaylorConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorConfig(; degree, gradients :: RFD.CFDStamp, hessians :: RFD.CFDStamp, max_evals)</code></pre><p>Configuration for a polynomial Taylor model using finite difference approximations of the derivatives. By default we have <code>degree = 2</code> and <code>gradients == hessians == RFD.CFDStamp(1,2)</code>, that is,  a first order central difference scheme of accuracy order 3 is recursed to compute the Hessians  and the gradients. In this case, the finite difference scheme is the same for both Hessians and gradients and we profit  from caching intermediate results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TransformerFn" href="#Morbit.TransformerFn"><code>Morbit.TransformerFn</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return the <code>TransformerFn</code> defined by <code>mop</code> with a minimum precision of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.TransformerFn-Tuple{AbstractVector{var&quot;#s72&quot;} where var&quot;#s72&quot;&lt;:Real}" href="#Morbit.TransformerFn-Tuple{AbstractVector{var&quot;#s72&quot;} where var&quot;#s72&quot;&lt;:Real}"><code>Morbit.TransformerFn</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unscale the point <code>x̂</code> from internal to original domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachindex-Tuple{Morbit.AbstractDB}" href="#Base.eachindex-Tuple{Morbit.AbstractDB}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>List of all <code>id :: Int</code> belonging to the stored results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Morbit.AbstractDB}" href="#Base.length-Tuple{Morbit.AbstractDB}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of entries in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._add!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective, Union{Nothing, Vector{Int64}}}" href="#Morbit._add!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective, Union{Nothing, Vector{Int64}}}"><code>Morbit._add!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add an objective function to MOP with specified output indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._backtrack-NTuple{5, Any}" href="#Morbit._backtrack-NTuple{5, Any}"><code>Morbit._backtrack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a backtracking loop starting at <code>x</code> with an initial step of <code>step_size .* dir</code> and return trial point <code>x₊</code>, the surrogate value-vector <code>m_x₊</code> and the final step <code>s = x₊ .- x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/descent.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._consume_points-NTuple{7, Any}" href="#Morbit._consume_points-NTuple{7, Any}"><code>Morbit._consume_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_consume_points(data_base, poised_points, poised_indices, candidate_indices)</code></pre><p>Helper to return array of database indices for <code>poised_points</code> and  <code>poised_indices</code>. Add result to database if index is -1. <code>candidate_indices</code> are the database indices of the points from the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/LagrangeModel.jl#L407-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._del!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}" href="#Morbit._del!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}"><code>Morbit._del!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove an objective function from MOP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit._eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit._eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate (internal) output <code>ℓ</code> of TaylorModel <code>tm</code>, provided a difference vector <code>h = x - x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_optim_handle-Tuple{Morbit.SurrogateModel, Int64}" href="#Morbit._get_optim_handle-Tuple{Morbit.SurrogateModel, Int64}"><code>Morbit._get_optim_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function handle to be used with <code>NLopt</code> for output <code>ℓ</code> of <code>model</code>. That is, if <code>model</code> is a surrogate for two scalar objectives, then <code>ℓ</code> must  be either 1 or 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/SurrogatesImplementation.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_ps_constraint_func-Tuple{Morbit.SurrogateContainer, Any, Any, Any}" href="#Morbit._get_ps_constraint_func-Tuple{Morbit.SurrogateContainer, Any, Any, Any}"><code>Morbit._get_ps_constraint_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_ps_constraint_func( sc :: SurrogateContainer, mx, dir, l )</code></pre><p>Return the <code>l</code>-th (possibly non-linear) constraint function  for Pascoletti-Serafini. <code>dir</code> .&gt;= 0 is the image direction; <code>χ = [t;x]</code> is the augmented variable vector;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/descent.jl#L345-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._get_ps_objective_func-Tuple{}" href="#Morbit._get_ps_objective_func-Tuple{}"><code>Morbit._get_ps_objective_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return objective function for Pascoletti-Serafini, modifying gradient in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/descent.jl#L365-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._init_model-Tuple{ExactConfig, Morbit.AbstractObjective, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig, Morbit.ExactMeta}" href="#Morbit._init_model-Tuple{ExactConfig, Morbit.AbstractObjective, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig, Morbit.ExactMeta}"><code>Morbit._init_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return an ExactModel build from a VectorObjectiveFunction <code>objf</code>.  Model is the same inside and outside of criticality round.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._intersect_bounds-NTuple{4, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._intersect_bounds-NTuple{4, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._intersect_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return smallest positive and biggest negative and <code>σ₊</code> and <code>σ₋</code> so that <code>x .+ σ± .* d</code> stays within bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._local_bounds-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit._local_bounds-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit._local_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return lower and upper bound vectors combining global and trust region constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._objf_index-Tuple{Morbit.AbstractObjective, Morbit.AbstractMOP}" href="#Morbit._objf_index-Tuple{Morbit.AbstractObjective, Morbit.AbstractMOP}"><code>Morbit._objf_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Position of <code>objf</code> in <code>list_of_objectives(mop)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._ps_optimization-Union{Tuple{F}, Tuple{Morbit.SurrogateContainer, Symbol, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, AbstractVector{F}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, Int64}} where F" href="#Morbit._ps_optimization-Union{Tuple{F}, Tuple{Morbit.SurrogateContainer, Symbol, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, AbstractVector{F}, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64, Int64}} where F"><code>Morbit._ps_optimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct and solve Pascoletti Serafini subproblem using surrogates from <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/descent.jl#L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._steepest_descent_direction-Union{Tuple{F}, Tuple{AbstractVector{F}, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}} where F&lt;:AbstractFloat" href="#Morbit._steepest_descent_direction-Union{Tuple{F}, Tuple{AbstractVector{F}, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}} where F&lt;:AbstractFloat"><code>Morbit._steepest_descent_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Provided <code>x</code> and the (surrogate) jacobian <code>∇F</code> at <code>x</code>, as well as bounds <code>lb</code> and <code>ub</code>, return steepest multi descent direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/descent.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._wrap_func-Union{Tuple{O}, Tuple{T}, Tuple{Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:Morbit.OutTypeWrapper{T, O}, Function, Morbit.SurrogateConfig, Int64, Int64}} where {T, O}" href="#Morbit._wrap_func-Union{Tuple{O}, Tuple{T}, Tuple{Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:Morbit.OutTypeWrapper{T, O}, Function, Morbit.SurrogateConfig, Int64, Int64}} where {T, O}"><code>Morbit._wrap_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A general constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit._wrap_func-Union{Tuple{T}, Tuple{T, Function, Morbit.SurrogateConfig, Int64, Int64}} where T&lt;:(Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:Morbit.AbstractObjective)" href="#Morbit._wrap_func-Union{Tuple{T}, Tuple{T, Function, Morbit.SurrogateConfig, Int64, Int64}} where T&lt;:(Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:Morbit.AbstractObjective)"><code>Morbit._wrap_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A general constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!" href="#Morbit.add_objective!"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_objective!( mop :: MixedMOP, func :: T where{T &lt;: Function}, type :: Symbol = :expensive, n_out :: Int64 = 1, can_batch :: Bool = false )</code></pre><p>Add scalar-valued objective function <code>func</code> to <code>mop</code> structure. <code>func</code> must take an <code>Vec</code> as its (first) argument, i.e. represent a function <span>$f: ℝ^n → ℝ$</span>. <code>type</code> must either be <code>:expensive</code> or <code>:cheap</code> to determine whether the function is replaced by a surrogate model or not.</p><p>If <code>type</code> is <code>:cheap</code> and <code>func</code> takes 1 argument only then its gradient is calculated by ForwardDiff. A cheap function <code>func</code> with custom gradient function <code>grad</code> (representing <span>$∇f : ℝ^n → ℝ^n$</span>) is added by</p><pre><code class="nohighlight hljs">add_objective!(mop, func, grad)</code></pre><p>The optional argument <code>n_out</code> allows for the specification of vector-valued objective functions. This is mainly meant to be used for <em>expensive</em> functions that are in some sense inter-dependent.</p><p>The flag <code>can_batch</code> defaults to false so that the objective function is simply looped over a bunch of arguments if required. If <code>can_batch == true</code> then the objective function must be able to return an array of results when provided an array of input vectors (whilst still returning a single result, not a singleton array containing the result, for a single input vector).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># Define 2 scalar objective functions and a MOP ℝ^2 → ℝ^2

f1(x) =  x[1]^2 + x[2]

f2(x) = exp(sum(x))
∇f2(x) = exp(sum(x)) .* ones(2);

mop = MixedMOP()
add_objective!(mop, f1, :cheap)     # gradient will be calculated using ForwardDiff
add_objective!(mop, f2, ∇f2 )       # gradient is provided</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/adding_objectives.jl#L23-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!-Tuple{MixedMOP, Function, Function}" href="#Morbit.add_objective!-Tuple{MixedMOP, Function, Function}"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_objective!( mop :: MixedMOP, func :: T where{T &lt;: Function}, grad :: T where{T &lt;: Function})</code></pre><p>Add scalar-valued objective function <code>func</code> and its vector-valued gradient <code>grad</code> to <code>mop</code> struture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/adding_objectives.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}" href="#Morbit.add_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}"><code>Morbit.add_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a scalar objective to <code>mop::MixedMOP</code> modelled according to <code>model_config</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/adding_objectives.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.add_vector_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}" href="#Morbit.add_vector_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}"><code>Morbit.add_vector_objective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a vector objective to <code>mop::MixedMOP</code> modelled according to <code>model_config</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/adding_objectives.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.combine-Union{Tuple{F}, Tuple{T}, Tuple{T, F}} where {T&lt;:Morbit.AbstractObjective, F&lt;:Morbit.AbstractObjective}" href="#Morbit.combine-Union{Tuple{F}, Tuple{T}, Tuple{T, F}} where {T&lt;:Morbit.AbstractObjective, F&lt;:Morbit.AbstractObjective}"><code>Morbit.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine two objectives. Only needed if <code>combinable</code> can return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.combine-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F&lt;:Function, T&lt;:Function}" href="#Morbit.combine-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F&lt;:Function, T&lt;:Function}"><code>Morbit.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a new function function handle stacking the output of <code>func1</code> and <code>func2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/BatchObjectiveFunction.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.copy_db-Union{Tuple{DBT}, Tuple{DBT, Type}} where DBT&lt;:Morbit.AbstractDB" href="#Morbit.copy_db-Union{Tuple{DBT}, Tuple{DBT, Type}} where DBT&lt;:Morbit.AbstractDB"><code>Morbit.copy_db</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a new database of same &#39;base&#39; type but with different saveable type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_all_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_all_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_all_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(Internally) Evaluate all objectives at site <code>x̂::Vec</code>. Objective order might differ from order in which they were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_and_sort_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_and_sort_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_and_sort_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate all objectives at site <code>x̂::Vec</code> and sort the result according to the order in which objectives were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_handle-Tuple{Morbit.AbstractObjective}" href="#Morbit.eval_handle-Tuple{Morbit.AbstractObjective}"><code>Morbit.eval_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function that evaluates an objective at an <strong>unscaled</strong> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate output <code>ℓ</code> of the ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.SurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.SurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return model value for output <code>l</code> of <code>sc</code> at <code>x̂</code>. Index <code>l</code> is assumed to be an <em>internal</em> index in the range of 1,…,n<em>objfs, where n</em>objfs is the total number of (scalarized) objectives stored in <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/SurrogatesImplementation.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate (internal) output <code>ℓ</code> of <code>tm</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate output <code>ℓ</code> of <code>mod::RbfModel</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/RbfModel.jl#L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_models</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>mod::RbfModel</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/RbfModel.jl#L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_objf-Tuple{Morbit.AbstractObjective, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_objf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the objective at unscaled site <code>x</code>. and increase counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.eval_objf-Tuple{Morbit.AbstractObjective, Morbit.TransformerFn, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, Morbit.TransformerFn, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.eval_objf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate the objective at scaled site <code>x̂</code> with help of <code>tfn</code>. Used in <code>diff_wrappers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_lower_bounds-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_lower_bounds-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_lower_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return full vector of lower variable vectors for original problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_lower_bounds_internal-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_lower_bounds_internal-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_lower_bounds_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return lower variable bounds for scaled variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_upper_bounds-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_upper_bounds-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_upper_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return full vector of upper variable vectors for original problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.full_upper_bounds_internal-Tuple{Morbit.AbstractMOP}" href="#Morbit.full_upper_bounds_internal-Tuple{Morbit.AbstractMOP}"><code>Morbit.full_upper_bounds_internal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return upper variable bounds for scaled variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gradient vector of output <code>ℓ</code> of <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{Morbit.SurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{Morbit.SurrogateContainer, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a gradient for output <code>l</code> of <code>sc</code> at <code>x̂</code>. Index <code>l</code> is assumed to be an internal index in the range of 1,…,n<em>objfs, where n</em>objfs is the total number of (scalarized) objectives stored in <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/SurrogatesImplementation.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_gradient-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}" href="#Morbit.get_gradient-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}"><code>Morbit.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gradient vector of output <code>ℓ</code> of <code>mod</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/RbfModel.jl#L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_id-Tuple{Morbit.AbstractResult}" href="#Morbit.get_id-Tuple{Morbit.AbstractResult}"><code>Morbit.get_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_id( res :: AbstractResult ) :: Int</code></pre><p>Return the <code>id</code> of a result such that for the database <code>db</code>  conataining <code>res</code> it holds that <code>get_result(db, id) == res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractResultInterface.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_jacobian-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.get_jacobian-Tuple{Morbit.ExactModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.get_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jacobian Matrix of ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/ExactModel.jl#L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_jacobian-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#Morbit.get_jacobian-Tuple{RbfModel, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>Morbit.get_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jacobian Matrix of ExactModel <code>em</code> at scaled site <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/RbfModel.jl#L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_optim_handle-Tuple{Morbit.SurrogateContainer, Int64}" href="#Morbit.get_optim_handle-Tuple{Morbit.SurrogateContainer, Int64}"><code>Morbit.get_optim_handle</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function handle to be used with <code>NLopt</code> for output <code>l</code> of <code>sc</code>. Index <code>l</code> is assumed to be an <em>internal</em> index in the range of <code>1, …, n_objfs</code>, where <code>n_objfs</code> is the total number of (scalarized) objectives stored in <code>sc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/SurrogatesImplementation.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_poised_set-Union{Tuple{Any}, Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s160&quot;, N} where {var&quot;#s160&quot;&lt;:Real, N})" href="#Morbit.get_poised_set-Union{Tuple{Any}, Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s160&quot;, N} where {var&quot;#s160&quot;&lt;:Real, N})"><code>Morbit.get_poised_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )</code></pre><p>Compute a point set suited for polynomial interpolation.</p><p>Input:</p><ul><li><code>basis</code>: A vector of polynomials constituting a basis for the polynomial space.</li><li><code>points</code>: (optional) A set of candidate points to be tried for inclusion into the poised set.</li><li><code>solver</code>: NLopt solver to use. Should be derivative-free.</li><li><code>max_solver_evals</code>: Maximum number of evaluations in each optimization run. </li></ul><p>Return:</p><ul><li><code>poised_points :: Vector{T}</code> where <code>T</code> is either a <code>Vector{F}</code> or an <code>SVector{n_vars, F}</code> and <code>F</code> is the precision of the points in <code>points</code>, but at least <code>Float32</code>. </li><li><code>lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}</code>: The Lagrange basis corresponding to <code>poised_points</code>.</li><li><code>point_indices</code>: An array indicating which points from <code>points</code> are also in <code>poised_points</code>. A positive entry corresponds to the index of a poised point in <code>points</code>. If a poised point is new, then the entry is <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/LagrangeModel.jl#L171-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_result-Union{Tuple{F}, Tuple{Morbit.AbstractDB{F}, Int64}} where F" href="#Morbit.get_result-Union{Tuple{F}, Tuple{Morbit.AbstractDB{F}, Int64}} where F"><code>Morbit.get_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get result with <code>id</code> from database <code>db</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_scaling_poly-Tuple{Any, Any, Any}" href="#Morbit.get_scaling_poly-Tuple{Any, Any, Any}"><code>Morbit.get_scaling_poly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return vector of polynomials that scales variables from [lb, ub] to [0,1]^n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/LagrangeModel.jl#L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_site-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F" href="#Morbit.get_site-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F"><code>Morbit.get_site</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the site vector associated with a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractResultInterface.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_unscaling_poly-Tuple{Any, Any, Any}" href="#Morbit.get_unscaling_poly-Tuple{Any, Any, Any}"><code>Morbit.get_unscaling_poly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return vector of polynomials that unscales variables from [0,1]^n to [lb,ub].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/LagrangeModel.jl#L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.get_value-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F" href="#Morbit.get_value-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F"><code>Morbit.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the value vector associated with a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractResultInterface.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.grow_radius-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.grow_radius-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.grow_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grow radius according to <code>min( Δ_max, γ * Δ )</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.grow_radius-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.grow_radius-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.grow_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grow radius according to <code>min( Δ_max, (γ + ||s||/Δ) * Δ )</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.inc_evals!" href="#Morbit.inc_evals!"><code>Morbit.inc_evals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Increase evaluation count by <code>N</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_db-Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.AbstractDB, Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:AbstractFloat, Union{Type{var&quot;#s41&quot;} where var&quot;#s41&quot;&lt;:Nothing, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Morbit.AbstractIterSaveable}}" href="#Morbit.init_db-Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:Morbit.AbstractDB, Type{var&quot;#s42&quot;} where var&quot;#s42&quot;&lt;:AbstractFloat, Union{Type{var&quot;#s41&quot;} where var&quot;#s41&quot;&lt;:Nothing, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Morbit.AbstractIterSaveable}}"><code>Morbit.init_db</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructor for empty database of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_res-Union{Tuple{T}, Tuple{T, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}} where T&lt;:(Type{var&quot;#s72&quot;} where var&quot;#s72&quot;&lt;:Morbit.AbstractResult)" href="#Morbit.init_res-Union{Tuple{T}, Tuple{T, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Int64}} where T&lt;:(Type{var&quot;#s72&quot;} where var&quot;#s72&quot;&lt;:Morbit.AbstractResult)"><code>Morbit.init_res</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructor for a result, taking site and value vector and id in database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractResultInterface.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.init_surrogates-Tuple{Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig}" href="#Morbit.init_surrogates-Tuple{Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig}"><code>Morbit.init_surrogates</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a SurrogateContainer initialized from the information provided in <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/SurrogatesImplementation.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.is_transformed-Tuple{Morbit.AbstractDB}" href="#Morbit.is_transformed-Tuple{Morbit.AbstractDB}"><code>Morbit.is_transformed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bool indicating if the database data been transformed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.list_of_objectives-Tuple{Morbit.AbstractMOP}" href="#Morbit.list_of_objectives-Tuple{Morbit.AbstractMOP}"><code>Morbit.list_of_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a list of <code>AbstractVectorObjective</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.local_bounds-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}" href="#Morbit.local_bounds-Tuple{Morbit.AbstractMOP, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Union{Real, AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}}"><code>Morbit.local_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local bounds vectors <code>lb_eff</code> and <code>ub_eff</code> using scaled variable constraints from <code>mop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.make_set_lambda_poised-Union{Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s160&quot;, N} where {var&quot;#s160&quot;&lt;:Real, N})" href="#Morbit.make_set_lambda_poised-Union{Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T&lt;:(AbstractArray{var&quot;#s160&quot;, N} where {var&quot;#s160&quot;&lt;:Real, N})"><code>Morbit.make_set_lambda_poised</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_set_lambda_poised( basis, points; 
    LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )</code></pre><p>Make the output of <code>get_poised_set</code> even better suited for interpolation.</p><p>Input:</p><ul><li><code>basis</code>: A vector of polynomials constituting a Lagrange basis for the polynomial space.</li><li><code>points</code>: The vector of points belonging to the Lagrange basis.</li><li><code>LAMBDA :: Real &gt; 1</code>: Determines the quality of the interpolation. </li><li><code>solver</code>: NLopt solver to use. Should be derivative-free.</li><li><code>max_solver_evals</code>: Maximum number of evaluations in each optimization run. </li><li><code>max_loops</code>: Maximum number of loops that try to make the set Λ-poised.</li><li><code>skip_indices</code>: Inidices of points to discard last.</li></ul><p>Return:</p><ul><li><code>poised_points :: Vector{T}</code> where <code>T</code> is either a <code>Vector{F}</code> or an <code>SVector{n_vars, F}</code> and <code>F</code> is the precision of the points in <code>points</code>, but at least <code>Float32</code>. </li><li><code>lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}</code>: The Lagrange basis corresponding to <code>poised_points</code>.</li><li><code>point_indices</code>: An array indicating which points from <code>points</code> are also in <code>poised_points</code>. A positive entry corresponds to the index of a poised point in <code>points</code>. If a poised point is new, then the entry is <code>-1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/LagrangeModel.jl#L260-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.max_evals-Tuple{Morbit.AbstractObjective}" href="#Morbit.max_evals-Tuple{Morbit.AbstractObjective}"><code>Morbit.max_evals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(Soft) upper bound on the number of function calls. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.new_result!" href="#Morbit.new_result!"><code>Morbit.new_result!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Add a new result to the database, return its id of type Int.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_evals!-Tuple{Morbit.AbstractObjective, Int64}" href="#Morbit.num_evals!-Tuple{Morbit.AbstractObjective, Int64}"><code>Morbit.num_evals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set evaluation counter to <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_evals-Tuple{Morbit.AbstractObjective}" href="#Morbit.num_evals-Tuple{Morbit.AbstractObjective}"><code>Morbit.num_evals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of calls to the original objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractObjectiveInterface.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.num_objectives-Tuple{Morbit.AbstractMOP}" href="#Morbit.num_objectives-Tuple{Morbit.AbstractMOP}"><code>Morbit.num_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of scalar-valued objectives of the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.pop_objf!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}" href="#Morbit.pop_objf!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}"><code>Morbit.pop_objf!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove <code>objf</code> from <code>list_of_objectives(mop)</code> and return its output indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reset_evals!-Tuple{Morbit.AbstractMOP}" href="#Morbit.reset_evals!-Tuple{Morbit.AbstractMOP}"><code>Morbit.reset_evals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set evaluation counter to 0 for each VectorObjectiveFunction in <code>m.vector_of_objectives</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.results_in_box_indices" href="#Morbit.results_in_box_indices"><code>Morbit.results_in_box_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return indices of results in <code>db</code> that lie in a box with corners <code>lb</code> and <code>ub</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reverse_internal_sorting-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.reverse_internal_sorting-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.reverse_internal_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort an interal objective vector so that the objectives are in the order in which they were added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.reverse_internal_sorting_indices-Tuple{Morbit.AbstractMOP}" href="#Morbit.reverse_internal_sorting_indices-Tuple{Morbit.AbstractMOP}"><code>Morbit.reverse_internal_sorting_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return index vector so that an internal objective vector is sorted according to the order the objectives where added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.scale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.scale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Scale variables fully constrained to a closed interval to [0,1] internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.set_transformed!-Tuple{Morbit.AbstractDB, Bool}" href="#Morbit.set_transformed!-Tuple{Morbit.AbstractDB, Bool}"><code>Morbit.set_transformed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the flag indicating whether the database data has been transformed or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractDBInterface.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.shrink_radius-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.shrink_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.shrink_radius-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.shrink_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * ||s||</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius_much-Tuple{Val{:standard}, Any, Any, Any}" href="#Morbit.shrink_radius_much-Tuple{Val{:standard}, Any, Any, Any}"><code>Morbit.shrink_radius_much</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius much according to <code>γ * Δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.shrink_radius_much-Tuple{Val{:steplength}, Any, Any, Any}" href="#Morbit.shrink_radius_much-Tuple{Val{:steplength}, Any, Any, Any}"><code>Morbit.shrink_radius_much</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Shrink radius according to <code>γ * ||s||</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/Morbit.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.unique_with_indices-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#Morbit.unique_with_indices-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Morbit.unique_with_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return <code>unique_elems, indices = unique_with_indices(arr)</code> such that  <code>unique_elems[indices] == arr</code> (and <code>unique_elems == unique(arr)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/TaylorModel.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Morbit.unscale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}" href="#Morbit.unscale-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, Morbit.AbstractMOP}"><code>Morbit.unscale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reverse scaling for fully constrained variables from [0,1] to their former domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/manuelbb-upb/Morbit.jl/blob/aec32113a26329b55b6ffc1e6e33e305d2387dbd/src/AbstractMOPInterface.jl#L83">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_logging/">« Pretty Printing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Monday 30 August 2021 14:44">Monday 30 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
