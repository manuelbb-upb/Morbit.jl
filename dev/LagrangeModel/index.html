<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LagrangeModels · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/LagrangeModel/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../composites/">Composite Functions</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li class="is-active"><a class="tocitem" href>LagrangeModels</a><ul class="internal"><li><a class="tocitem" href="#Intro-and-Prerequisites"><span>Intro and Prerequisites</span></a></li><li><a class="tocitem" href="#Surrogate-Interface-Implementations"><span>Surrogate Interface Implementations</span></a></li><li><a class="tocitem" href="#Construction"><span>Construction</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#lagrange_summary"><span>Summary &amp; Quick Examples</span></a></li></ul></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebooks/notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebooks/notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../dev_man/">DocStrings</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Models</a></li><li class="is-active"><a href>LagrangeModels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>LagrangeModels</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/main/src/models/LagrangeModel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lagrange-Polynomial-Models"><a class="docs-heading-anchor" href="#Lagrange-Polynomial-Models">Lagrange Polynomial Models</a><a id="Lagrange-Polynomial-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-Polynomial-Models" title="Permalink"></a></h1><p>This file is automatically generated from source code. For usage examples refer to <a href="#lagrange_summary">Summary &amp; Quick Examples</a>.</p><h2 id="Intro-and-Prerequisites"><a class="docs-heading-anchor" href="#Intro-and-Prerequisites">Intro and Prerequisites</a><a id="Intro-and-Prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Intro-and-Prerequisites" title="Permalink"></a></h2><p>Polyoniaml interpolation models are a common choice for surrogate modeling. In our setting we want to construct models for <span>$n$</span>-variate objectives and use polynomials of degree 1 or 2. We hence need a basis for the space <span>$Π_n^d$</span> of polynomials. Given a point set that is suited for interpolation (a <em>poised</em> set) we can use the Lagarange basis <span>$\{l_i\}$</span> with <span>$l_i(x_j) = δ_{i,j}$</span> to easily find the coefficients for vector valued models.</p><p>We use <code>DynamicPolynomials</code> for polynomial arithmetic, <code>NLopt</code> to optimize polynomials and some more packages:</p><pre><code class="language-julia hljs">using DynamicPolynomials
import NLopt
import Combinatorics</code></pre><h2 id="Surrogate-Interface-Implementations"><a class="docs-heading-anchor" href="#Surrogate-Interface-Implementations">Surrogate Interface Implementations</a><a id="Surrogate-Interface-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-Interface-Implementations" title="Permalink"></a></h2><p>The model itself is defined only by its vector of Lagrange basis polynomials and the coefficients.</p><pre><code class="language-julia hljs">@with_kw mutable struct LagrangeModel{
        B &lt;: AbstractArray{&lt;:AbstractPolynomialLike},
        G &lt;: AbstractArray{&lt;:AbstractArray{&lt;:AbstractPolynomialLike}},
        V &lt;: AbstractVector{&lt;:AbstractVector{&lt;:AbstractFloat} } } &lt;: AbstractSurrogate
    basis :: B  # basis polynomials
    grads :: G  # gradient polynomials for all the basis polynomials
    coeff :: V  # coefficients to interpolate data with `basis`
    fully_linear :: Bool = false
    num_outputs :: Int = -1
end

fully_linear( lm :: LagrangeModel ) = lm.fully_linear
num_outputs( lm :: LagrangeModel ) = lm.num_outputs

function set_fully_linear!(lm :: LagrangeModel, val )
	lm.fully_linear = val
	return nothing
end</code></pre><p>There is a multitude of configuration parameters, most of which will be explained later:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    LagrangeConfig(; kwargs... )

Configuration for Lagrange Polyoniaml models.

$(FIELDS)
&quot;&quot;&quot;
@with_kw mutable struct LagrangeConfig &lt;: AbstractSurrogateConfig

    &quot;Degree of the surrogate model polynomials.&quot;
    degree :: Int = 2

    &quot;Enlargement parameter to consider more points for inclusion.&quot;
    θ_enlarge :: Float64 = 2.0

    &quot;Quality parameter in Λ-Poisedness Algorithm.&quot;
    LAMBDA :: Float64 = 1.5

    &quot;Whether or not the interpolation sets must be Λ-poised (and the models fully linear).&quot;
    allow_not_linear :: Bool = false

    &quot;Whether or not to try to construct a new interpolation set in each iteration.&quot;
    optimized_sampling :: Bool = true

    # if optimized_sampling = false, shall we try to use saved sites?
    &quot;Path to look at for a pre-saved poised set of interpolation points in [0,1]^n.&quot;
    save_path :: String = &quot;&quot;

    &quot;Lock to use parallel setups if multiple models can access `save_path`.&quot;
    io_lock :: Union{Nothing, Threads.ReentrantLock} = nothing

    &quot;Maximum number of polynomial evaluations to find a poised set.&quot;
    algo1_max_evals :: Int = -1

    &quot;Maximum number of polynomial evaluations to make a set Λ-poised.&quot;
    algo2_max_evals :: Int = -1

    &quot;NLopt Solver to use for the poisedness problem.&quot;
    algo1_solver :: Symbol = :LN_BOBYQA
    &quot;NLopt Solver to use for the Λ-poisedness problem.&quot;
    algo2_solver :: Symbol = :LN_BOBYQA

    &quot;Maximum number of evaluations allowed to the true objective(s).&quot;
    max_evals :: Int64 = typemax(Int64);

    @assert 1 &lt;= degree &lt;= 2 &quot;Only linear and quadratic models are supported.&quot;
    @assert LAMBDA &gt; 1 &quot;`LAMBDA` must be &gt; 1.&quot;
    @assert let algo_str = string( algo1_solver );
        length( algo_str ) &gt; 2 &amp;&amp; string(algo_str[2]) == &quot;N&quot;
    end &quot;`algo1_solver` must be a derivative-free NLopt algorithm.&quot;
    @assert let algo_str = string( algo2_solver );
        length( algo_str ) &gt; 2 &amp;&amp; string(algo_str[2]) == &quot;N&quot;
    end &quot;`algo2_solver` must be a derivative-free NLopt algorithm.&quot;
end</code></pre><p>Overwrite <code>lock</code> and <code>unlock</code> so we can use <code>nothing</code> as a &quot;lock&quot;:</p><pre><code class="language-julia hljs">function Base.lock(::Nothing) end
function Base.unlock(::Nothing) end</code></pre><p>The required method implementations are straightforward. Note, thate we allow the models to be combined to vector functions if they share the same configuration to avoid redundant efforts whilst constructing models.</p><pre><code class="language-julia hljs">max_evals( cfg :: LagrangeConfig ) :: Int = cfg.max_evals
combinable( cfg :: LagrangeConfig ) :: Bool = true</code></pre><p>We also need to introduce our own implementation for <code>isequal</code> and <code>hash</code> for <code>LagrangeConfig</code>s to be combinable, see <a href="https://docs.julialang.org/en/v1/base/base/">the docs too</a>.</p><pre><code class="language-julia hljs">function Base.hash( cfg :: LagrangeConfig, h :: UInt )
	return hash( getfield.( cfg, Tuple( fn for fn ∈ fieldnames(LagrangeConfig) ) ), h )
end
function Base.isequal( cfg1 :: LagrangeConfig, cfg2 :: LagrangeConfig )
	all( isequal( getfield(cfg1, fn), getfield(cfg2, fn) ) for fn in fieldnames( LagrangeConfig) )
end</code></pre><p>The <code>LagrangeMeta</code> simply holds the (sub-)database indices of the results we want to interpolate at. We also store the output indices of the model for convenience and carry polynomials that act on <span>$[0,1]^n$</span>.</p><pre><code class="language-julia hljs">@with_kw struct LagrangeMeta{
        CB &lt;: Union{Nothing, Vector{&lt;:AbstractPolynomialLike}},
        LB &lt;: Union{Nothing, Vector{&lt;:AbstractPolynomialLike}},
        P &lt;: Union{Nothing, AbstractVector{&lt;:AbstractVector{&lt;:Real}}}
    } &lt;: AbstractSurrogateMeta
    interpolation_indices :: Vector{Int} = []
    canonical_basis :: CB = nothing
    lagrange_basis :: LB = nothing  # store the lagrange basis acting on [0,1]^n
    stamp_points :: P = nothing     # used only if `optimized_sampling == false`
    fully_linear :: Bool = false
end

function get_saveable_type( T :: LagrangeConfig, x, y )
    return LagrangeMeta{Nothing,Nothing, Nothing}
end
function get_saveable( meta :: LagrangeMeta )
    return LagrangeMeta(;
        interpolation_indices = meta.interpolation_indices,
    )
end</code></pre><h2 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h2><h3 id="A-Bit-of-Theory"><a class="docs-heading-anchor" href="#A-Bit-of-Theory">A Bit of Theory</a><a id="A-Bit-of-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#A-Bit-of-Theory" title="Permalink"></a></h3><p>The canonical basis is obtained by calculating the non-negative integral solutions to the euqation</p><p class="math-container">\[x_1 + … + x_n \le d.\]</p><p>These solutions can be found using the <code>Combinatorics</code> package via <code>multiexponents(n,d)</code> (<code>d</code> must be successively increased).</p><pre><code class="language-julia hljs">function non_negative_ineq_solutions(deg, n_vars)
	Iterators.flatten( ( collect( Combinatorics.multiexponents( n_vars, d )) for d = 0 : deg ) )
end

function get_poly_basis( deg, n_vars)
	exponents = non_negative_ineq_solutions(deg, n_vars )
	polys = let
		@polyvar x[1:n_vars]
		[ prod(x.^e) for e in exponents ]
	end
	return polys
end</code></pre><p>We are going to use the canonical basis to determine a <strong>poised set</strong> of points. This does in fact work with any polynomial basis for <span>$Π_n^d$</span>. <br/>In the process of doing so, we also modify (a copy of?) the basis so that it becomes the Lagrange basis for the returned point set.</p><p>The Larange basis is formed by normalizing and orthogonalizing with respect to the point set:</p><pre><code class="language-julia hljs">function orthogonalize_polys( poly_arr, x, i )
	# normalize i-th polynomial with respect to `x`
	p_i = poly_arr[i] / poly_arr[i](x)

	# orthogonalize
	return [ j != i ? poly_arr[j] - ( poly_arr[j](x) * p_i ) : p_i for j = eachindex( poly_arr ) ]
end</code></pre><p>We use Algorithm 6.2 and Algorithm 6.3 from the book &quot;Introduction to Derivative-Free Optimization&quot; by Conn et. al. <br/>Algorithm 6.2 makes the set poised (suited for interpolation) and returns the corresponding Lagrange basis. Algorithm 6.3 takes the poised set and the Lagrange basis and tries to make it <span>$Λ$</span>-poised. <span>$Λ$</span> must be greater 1 and a smaller value makes the set more suited for good models.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )

Compute a point set suited for polynomial interpolation.

Input:
* `basis`: A vector of polynomials constituting a basis for the polynomial space.
* `points`: (optional) A set of candidate points to be tried for inclusion into the poised set.
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run.

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`.
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
&quot;&quot;&quot;
function get_poised_set( basis, points :: AbstractArray{T} = Vector{MIN_PRECISION}[];
		solver = :LN_BOBYQA, max_solver_evals = -1 ) where {
		T &lt;: AbstractArray{&lt;:Real}
	}

	p = length(basis)
	@assert p &gt; 0 &quot;`basis` must not be an empty array.&quot;

    @logmsg loglevel3 &quot;Trying to find a poised set with $(p) points.&quot;

	vars = variables( basis[end] )
	n_vars = length(vars)
	@assert n_vars &gt; 0 &quot;The number of variables must be positive.&quot;

	if max_solver_evals &lt; 0
		max_solver_evals = 2000 * n_vars
	end

	F = promote_type( eltype( T ), MIN_PRECISION )
	#P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}
    P_type = Vector{Vector{F}}
	ZERO_TOL = min(eps(F) * 100, eps(Float16) * 10)

	# indicates which points from points have been accepted
	point_indices = fill(-1, p)
	not_accepted_indices = collect( eachindex( points ) )
	# return array of points that form a poised set
	poised_points = P_type(undef, p)

	new_basis = basis
	for i = 1 : p
		_points = points[not_accepted_indices]

		# find the point that maximizes the i-th polynomial
		# if the polynomial is constant, then the first remaining point is used (j = 1)
		l_max, j = if isempty(_points)
			0.0, 0
		else
			findmax( abs.( [ new_basis[i]( x ) for x in _points ] ) )
		end

		if l_max &gt; ZERO_TOL
			# accept the `j`-th point from `_points`
			poised_points[i] = _points[j]
			### indicate what the actual point index was
			point_indices[i] = not_accepted_indices[j]
			### delete from further consideration
			deleteat!(not_accepted_indices, j)
		else
			# no point was suitable to add to the set
			# trying to find the maximizer for a | l_i(x) |
			opt = NLopt.Opt( solver, n_vars )
			opt.lower_bounds = zeros(F, n_vars )
            opt.upper_bounds = ones(F, n_vars )
            opt.maxeval = max_solver_evals
            opt.xtol_rel = 1e-3
            opt.max_objective = (x,g) -&gt; abs( new_basis[i](x) )

            # try to find a good starting point
			x₀_tmp = [ rand(F, n_vars) for i = 1 : 50 * n_vars ]
            x₀ = x₀_tmp[argmax( abs.(new_basis[i].(x₀_tmp)) ) ]

			_, ξ, ret = NLopt.optimize(opt, x₀)

			poised_points[i] = ξ
		end

		new_basis = orthogonalize_polys( new_basis, poised_points[i], i )
	end

	return poised_points, new_basis, point_indices
end

&quot;&quot;&quot;
    make_set_lambda_poised( basis, points;
        LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )

Make the output of `get_poised_set` even better suited for interpolation.

Input:
* `basis`: A vector of polynomials constituting a Lagrange basis for the polynomial space.
* `points`: The vector of points belonging to the Lagrange basis.
* `LAMBDA :: Real &gt; 1`: Determines the quality of the interpolation.
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run.
* `max_loops`: Maximum number of loops that try to make the set Λ-poised.
* `skip_indices`: Inidices of points to discard last.

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`.
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
&quot;&quot;&quot;
function make_set_lambda_poised( basis, points :: AbstractArray{T};
		LAMBDA :: Real = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1,
		max_loops = -1, skip_indices = [1,] ) where {
		T &lt;: AbstractArray{&lt;:Real}
	}

	@assert length(basis) == length(points) &quot;Polynomial array `basis` and point array `points` must have the same length.&quot;
	if length(points) &gt; 0
		n_vars = length(points[1])
		@assert n_vars &gt; 0 &quot;The number of variables must be positive.&quot;

		F = promote_type( eltype( T ), MIN_PRECISION )
		#P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}
        P_type = Vector{Vector{F}}

		if max_loops &lt; 0
			max_loops = length(basis) * 100
		end

		if max_solver_evals &lt; 0
			max_solver_evals = 2000 * n_vars
		end

       	@logmsg loglevel3 &quot;Trying $(max_loops) times to make a set poised with Λ = $(LAMBDA).&quot;

		new_basis = basis
		new_points = P_type(points)
		point_indices = collect(eachindex(new_points))

		for k = 1 : max_loops
            iₖ = -1
		    xₖ = points[1]
			for (i, polyᵢ) in enumerate(new_basis)
				opt = NLopt.Opt( solver, n_vars )
				opt.lower_bounds = zeros(F, n_vars)
				opt.upper_bounds = ones(F, n_vars)
				opt.maxeval = max_solver_evals
				opt.xtol_rel = 1e-3
				opt.max_objective = (x,g) -&gt; abs( polyᵢ( x ) )

                x₀ = points[i]

				abs_lᵢ, xᵢ, _ = NLopt.optimize(opt, x₀)

				if abs_lᵢ &gt; LAMBDA
					iₖ = i
					xₖ = xᵢ
					if iₖ ∉ skip_indices
						# i is not prioritized we can brake here
						break
					end#if
				end#if
			end#for

			if iₖ &gt; 0
                @logmsg loglevel4 &quot;Discarding point $(iₖ).&quot;
				# perform a point swap
				new_points[iₖ] = xₖ
				point_indices[iₖ] = -1
				# adapt coefficients of lagrange basis
				new_basis = orthogonalize_polys( new_basis, xₖ, iₖ )
			else
				# we are done, the set is lambda poised
				break
			end#if
		end#for

		return new_points, new_basis, point_indices
	else
		return points, basis, collect(eachindex(points))
	end

end</code></pre><p>And a convenient function that combines both steps:</p><pre><code class="language-julia hljs">function get_lambda_poised_set( basis, points; solver1 = :LN_BOBYQA, solver2 = :LN_BOBYQA, max_solver_evals1 = -1, max_solver_evals2 = -1, LAMBDA = 1.5, max_lambda_loops = -1 )
	lagrange_points, lagrange_basis, lagrange_indices = get_poised_set(
		basis, points; solver = solver1, max_solver_evals = max_solver_evals1 )
	lambda_points, lambda_basis, lambda_indices = make_set_lambda_poised(
		lagrange_basis, lagrange_points; LAMBDA, max_loops = max_lambda_loops,
		solver = solver2, max_solver_evals = max_solver_evals2 )
	combined_indices = [ i &lt; 0 ? i : lagrange_indices[j] for (j,i) in enumerate( lambda_indices ) ]
	return lambda_points, lambda_basis, combined_indices
end</code></pre><p>We actually only try to find points suitable points in the hypercube <span>$[0,1]^n$</span>. The points can be (un)scaled with the usual methods. But for <code>Polynomial</code>s we can actually use substition to make evaluation more effective.</p><pre><code class="language-julia hljs">&quot;Return vector of polynomials that unscales variables from [0,1]^n to [lb,ub].&quot;
function get_unscaling_poly( vars, lb, ub )
    # we don&#39;t have to check for Inf here because of finite trust region
    w = ub .- lb
    return vars .* w .+ lb
end

&quot;Return vector of polynomials that scales variables from [lb, ub] to [0,1]^n.&quot;
function get_scaling_poly( vars, lb, ub )
    w = ub .- lb
    return ( vars .- lb ) ./ w
end</code></pre><h3 id="Method-Implementations"><a class="docs-heading-anchor" href="#Method-Implementations">Method Implementations</a><a id="Method-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Implementations" title="Permalink"></a></h3><p>We will use the functions from above in the <code>prepare_XXX</code> routines:<br/>The initial <code>prepare_init_model</code> function should return a meta object that can be used to build an initial surrogate model. We delegate the work to <code>prepare_update_model</code>.</p><pre><code class="language-julia hljs">function prepare_init_model(
        cfg :: LagrangeConfig, func_indices,
        mop, scal, x_it,
        sdb, ac;
	    ensure_fully_linear = true, kwargs...
    )

    n_vars = num_vars( mop )

	meta = LagrangeMeta(;
        canonical_basis = get_poly_basis( cfg.degree, n_vars )
    )

	return prepare_update_model(nothing, meta, cfg, func_indices, mop, scal, x_it, sdb, ac; ensure_fully_linear, kwargs...)
end</code></pre><p>Usually, <code>prepare_update_model</code> would only accept a model as its first argument. Because of the trick from above, we actually allow <code>nothing</code>, too.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    _consume_points(data_base, poised_points, poised_indices, candidate_indices)

Helper to return array of database indices for `poised_points` and
`poised_indices`. Add result to database if index is -1.
`candidate_indices` are the database indices of the points from the trust region.
&quot;&quot;&quot;
function _consume_points( db, poised_points, poised_indices, candidate_indices, lb, ub )
    interpolation_indices = Int[]
    w = ub .- lb
    for (i,ind) in enumerate(poised_indices)
        if ind &lt; 0
            # we need an additional new site
            # every p ∈ `poised_points` was sampled with respect to [0,1]^n
            # supposing `lb,ub` are with respect to right trust region, `unscale`
            # puts `p` into that trust region (w.r.t. to global internal scaling)
            new_db_id = new_result!(db, _unscale_lb_w(poised_points[i], lb, w))
            push!(interpolation_indices, new_db_id)
        else
            # we could recycle a candidate point
            push!(interpolation_indices, candidate_indices[ind])
        end
    end
    return interpolation_indices
end

function _scale_poly_basis( poised_basis, lb, ub )
    # we modify the basis so that the input is scaled to [0,1]^n with respect to
    # the enlarged trust region bounds, because the poisedness algos sought points there
    poly_vars = variables( poised_basis[1] )
    scaling_poly = get_scaling_poly( poly_vars, lb, ub )

    zero_pol = sum( 0 .* poly_vars ) # TODO remove once https://github.com/JuliaAlgebra/DynamicPolynomials.jl/issues/92 is fixed

    return [ subs(p, poly_vars =&gt; scaling_poly) + zero_pol for p in poised_basis ]
end

function prepare_update_model( mod :: Union{Nothing, LagrangeModel},
    meta :: LagrangeMeta, cfg :: LagrangeConfig, func_indices,
    mop, scal, x_it,
    sdb, algo_config;
    ensure_fully_linear = true, kwargs... )

    @logmsg loglevel2 &quot;Building LagrangeModel for $(func_indices).&quot;
    x_scaled = get_x_scaled( x_it )
    n_vars = length(x_scaled)

    x_index = get_x_index( x_it, func_indices )

    db = get_sub_db( sdb, func_indices )

    Δ = get_delta( x_it )

    lb, ub = local_bounds(scal, x_scaled, Δ * cfg.θ_enlarge )

    if cfg.optimized_sampling
        # Find points in current trust region …
        candidate_indices = [x_index; results_in_box_indices( db, lb, ub, [x_index,] )]
        # … and scale them to [0,1]^n
        candidate_points = [_scale(ξ, lb, ub) for ξ in get_site.(db, candidate_indices)]

        # Get a poised set and lagrange basis from the candidates
        poised_points, poised_basis, poised_indices = get_poised_set(
            meta.canonical_basis, candidate_points;
            solver = cfg.algo1_solver, max_solver_evals = cfg.algo1_max_evals
        )

        fully_linear = false
        # Make set even better
        if ensure_fully_linear || !cfg.allow_not_linear
            ### We would like to keep x if possible
            skip_indices = let l = findfirst( i -&gt; i == 1, poised_indices );
                isnothing(l) ? [] : [l,]
            end

            poised_points, poised_basis, indices_2 = make_set_lambda_poised(
                poised_basis, poised_points;
                LAMBDA = cfg.LAMBDA, solver = cfg.algo2_solver,
                max_solver_evals = cfg.algo2_max_evals, skip_indices
            )

            # if some i ∈ `indices_2` is equal -1 then it is a new point and we keep the negative index
            # else it is an index of a p ∈ `poised_points` which should be kept. then:
            # `p == poised_points[ i ]` and the index of `p` in candidates is `poised_indices[i]`
            poised_indices = [ i &lt; 0 ? i : poised_indices[i] for i = indices_2 ]
            fully_linear = true
        end

        # if needed (∀ i ∈ poised_indices with i == -1) put results into sub database `db`
        # and get database indices needed for interpolation
        interpolation_indices = _consume_points( db, poised_points, poised_indices, candidate_indices, lb, ub )

        return LagrangeMeta(;
            interpolation_indices,
            canonical_basis = meta.canonical_basis,
            lagrange_basis = poised_basis,
            fully_linear
        )

    else
        # unoptimized sampling: we only look for a good point set once
        # in the very first iteration and store the basis and the points
        # in the meta data which is then passed through in subsequent iterations
        lpoints, lbasis = if isnothing(meta.lagrange_basis)
            candidate_points = [ fill(.5, n_vars) ]
            lagrange_points, lagrange_basis, _ = get_lambda_poised_set(
                meta.canonical_basis, candidate_points;
                solver1 = cfg.algo1_solver, solver2 = cfg.algo2_solver,
                max_solver_evals1 = cfg.algo1_max_evals, max_solver_evals2 = cfg.algo2_max_evals,
                LAMBDA = cfg.LAMBDA )

            lagrange_points, lagrange_basis
        else
            meta.stamp_points, meta.lagrange_basis
        end

        candidate_indices = [x_index,]
        lindices = fill(-1, length(lpoints))

        # check if x (scaled to [0,1] wrt trust region bounds) is center of `lpoints`
        #src TODO does using `≈` make problems for small trust region radii? `==` always fails
        x_s = _scale(x_scaled, lb, ub)
        x_in_points_index = findfirst(χ -&gt; χ ≈ x_s, lpoints )
        if !isnothing(x_in_points_index)
             lindices[ x_in_points_index ] = 1
        end

        interpolation_indices = _consume_points( db, lpoints, lindices, candidate_indices, lb, ub )

        return LagrangeMeta(;
            interpolation_indices,
            lagrange_basis = lbasis,
            stamp_points = lpoints,
            fully_linear = true
        )
    end
end#function</code></pre><p>The improvement preparation enforces a Λ-poised set:</p><pre><code class="language-julia hljs">function prepare_improve_model(mod :: Union{Nothing, LagrangeModel},
    meta :: LagrangeMeta, cfg :: LagrangeConfig, func_indices,
    mop, scal, x_it,
    sdb, algo_config;
    kwargs... )
    return prepare_update_model( mod, meta, cfg, func_indices, mop, scal, x_it, sdb, algo_config; ensure_fully_linear = true, kwargs...)
end</code></pre><p>Now, in the 2-phase construction process, first all <code>prepare_</code> functions are called for all surrogate models. Then, the unevaluated results are evaluated and we can proceed with the model building. As before, <code>_init_model</code> simply delegates work to <code>update_model</code>. <br/>Not much is left to do, only to retrieve the correct values from the database to use as coefficients. We also store the gradient (vector of polynomials) for each basis polynomial.</p><pre><code class="language-julia hljs">function init_model(
    meta :: LagrangeMeta, cfg :: LagrangeConfig, func_indices,
    mop, scal, x_it,
    sdb, algo_config;
    kwargs...)

	return update_model( nothing, meta, cfg, func_indices, mop, scal, x_it, sdb, algo_config )
end

function update_model( mod :: Union{Nothing, LagrangeModel},
    meta :: LagrangeMeta, cfg :: LagrangeConfig, func_indices,
    mop, scal, x_it,
    sdb, algo_config;
    kwargs... )

    db = get_sub_db( sdb, func_indices )
    coeff = get_value.(db, meta.interpolation_indices)

    Δ = get_delta( x_it )
    x_scaled = get_x_scaled( x_it )
    lb, ub = local_bounds(scal, x_scaled, Δ * cfg.θ_enlarge )

    # make polynomial basis act on current trust region instead of [0,1]^n
    scaled_basis = _scale_poly_basis( meta.lagrange_basis, lb, ub )
    return LagrangeModel(;
        coeff, fully_linear = meta.fully_linear,
        basis = scaled_basis,
        grads = [ differentiate( p, variables(p) ) for p in scaled_basis ],
        num_outputs = num_outputs(func_indices)
    ), meta
end

function improve_model(
    mod :: Union{Nothing, LagrangeModel},
    meta :: LagrangeMeta, cfg :: LagrangeConfig, func_indices,
    mop, scal, x_it,
    sdb, algo_config;
    kwargs... )
    return update_model( mod, meta, cfg, func_indices, mop, scal, x_it, sdb, algo_config )
end</code></pre><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>The evaluation of some output is</p><p class="math-container">\[\sum_{i=1}^p c_i l_i( x ),\]</p><p>where <span>$p = \dim Π_n^d$</span>.</p><pre><code class="language-julia hljs">function _eval_poly_vec( poly_vec, x )
    return [ p(x) for p in poly_vec ]
end

function eval_models( lm :: LagrangeModel, scal :: AbstractVarScaler, x̂ :: Vec, ℓ )
    return sum( c[ℓ] * p(x̂) for (c,p) in zip( lm.coeff, lm.basis ) )
end

function eval_models( lm :: LagrangeModel, scal :: AbstractVarScaler, x̂ :: Vec )
    return sum( c * p(x̂) for (c,p) in zip( lm.coeff, lm.basis ) )
end

function get_gradient( lm :: LagrangeModel, scal :: AbstractVarScaler, x̂ :: Vec, ℓ )
    sum( c[ℓ] * _eval_poly_vec(p,x̂) for (c,p) in zip( lm.coeff, lm.grads ) )
end

function get_jacobian( lm :: LagrangeModel, scal :: AbstractVarScaler, x_scaled :: Vec, rows = nothing )
    no_out = num_outputs(lm)
    indices = if isnothing(rows) 1:no_out else rows end
    grad_evals = [ _eval_poly_vec(p,x_scaled) for p in lm.grads ]
    T = promote_type( eltype(lm.coeff[1]), eltype(x_scaled) )
    J = Matrix{T}(undef, length(indices), length(x_scaled))
    for (i,ℓ)=enumerate(indices)
        J[i,:] = sum( c[ℓ] * g for (c,g) in zip( lm.coeff, grad_evals) )
    end
    return J
    #return transpose( hcat( (sum( c[ℓ] * g for (c,g) in zip( lm.coeff, grad_evals) ) for ℓ = 1 : no_out)... ) )
end</code></pre><h2 id="lagrange_summary"><a class="docs-heading-anchor" href="#lagrange_summary">Summary &amp; Quick Examples</a><a id="lagrange_summary-1"></a><a class="docs-heading-anchor-permalink" href="#lagrange_summary" title="Permalink"></a></h2><ol><li>To use the default configuration for a scalar objective <code>f</code> do<pre><code class="language-julia hljs">add_objective!(mop, f, LagrangeConfig())</code></pre></li><li>For a vector valued objective do<pre><code class="language-julia hljs">add_vector_objective!(mop, f, LagrangeConfig(); n_out = 2)</code></pre></li><li>If you want a linear polyonmial only:<pre><code class="language-julia hljs">add_objective!(mop, f, LagrangeConfig(;degree=1))</code></pre></li><li>By default, a new interpolation set is built in every iteration. To use a &quot;stamp&quot; instead, turn of optimized sampling:<pre><code class="language-julia hljs">add_objective!(mop, f, LagrangeConfig(;optimized_sampling=true))</code></pre></li></ol><h3 id="Complete-usage-example"><a class="docs-heading-anchor" href="#Complete-usage-example">Complete usage example</a><a id="Complete-usage-example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-usage-example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Morbit
Morbit.print_all_logs()
mop = MixedMOP(3)

F = x -&gt; [ sum( ( x .- 1 ).^2 ); sum( ( x .+ 1 ).^2 ) ]

add_vector_objective!( mop, F, LagrangeConfig() )
add_objective!( mop, F; model_cfg = LagrangeConfig() )

x_fin, f_fin, _ = optimize( mop, [-π, ℯ, 0])</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TaylorModel/">« TaylorModels</a><a class="docs-footer-nextpage" href="../notebooks/notebook_finite_differences/">Finite Differences »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 17 May 2022 09:34">Tuesday 17 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
