<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lagrange Interpolation · Morbit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/notebooks/notebook_polynomial_interpolation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Morbit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../../constraints/">Constraints</a></li><li><a class="tocitem" href="../../composites/">Composite Functions</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li class="is-active"><a class="tocitem" href>Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../../dev_man/">DocStrings</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Random Notebooks</a></li><li class="is-active"><a href>Lagrange Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lagrange Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/master/docs/src/notebooks/notebook_polynomial_interpolation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><style>
    table {
        display: table !important;
        margin: 2rem auto !important;
        border-top: 2pt solid rgba(0,0,0,0.2);
        border-bottom: 2pt solid rgba(0,0,0,0.2);
    }

    pre, div {
        margin-top: 1.4rem !important;
        margin-bottom: 1.4rem !important;
    }
</style>

<!-- PlutoStaticHTML.Begin -->
<!--
    # This information is used for caching.
    [PlutoStaticHTML.State]
    input_sha = "82012d577aa3f4c8a17e8ae42e5be8699cf7aae035a78d6f6e96e99bcbd777d2"
    julia_version = "1.6.5"
-->
<pre class='language-julia'><code class='language-julia'>begin
	import Pkg
	Pkg.activate(tempname())
	Pkg.add("DynamicPolynomials")
	Pkg.add("NLopt")
	Pkg.add("StaticArrays")
	Pkg.add("CairoMakie")
	Pkg.add("Makie")
	Pkg.add("Combinatorics")
	Pkg.add("BenchmarkTools")
end</code></pre>


<pre class='language-julia'><code class='language-julia'>begin
	using DynamicPolynomials
	using BenchmarkTools
	import NLopt
	using StaticArrays
	using Makie, CairoMakie
	using Combinatorics
end</code></pre>



<div class="markdown"><p>We denote by <span class="tex">$Π_n^d$</span> the space of <span class="tex">$n$</span>-variate Polyoniams of degree at most <span class="tex">$d$</span>. To construct polynomials we use <code>DynamicPolynomials.jl</code>.</p>
</div>


<div class="markdown"><p>The canonical basis is obtained by calculating the non-negative integral solutions to the euqation</p>
<p class="tex">$$x_1 &#43; … &#43; x_n \le d.$$</p>
</div>


<div class="markdown"><p>These solutions can be found using the <code>Combinatorics</code> package via <code>multiexponents&#40;n,d&#41;</code> &#40;<code>d</code> must be successively increased&#41;.</p>
</div>

<pre class='language-julia'><code class='language-julia'>function non_negative_ineq_solutions(deg, n_vars)
	collect(Iterators.flatten( ( collect(multiexponents( n_vars, d )) for d = 0 : deg ) ))
end</code></pre>
<pre id='var-non_negative_ineq_solutions' class='documenter-example-output'><code class='code-output'>non_negative_ineq_solutions (generic function with 1 method)</code></pre>

<pre class='language-julia'><code class='language-julia'>function get_poly_basis( deg, n_vars)
	exponents = non_negative_ineq_solutions(deg, n_vars )
	polys = let
		@polyvar x[1:n_vars]
		[ prod(x.^e) for e in exponents ]
	end
	return polys
end</code></pre>
<pre id='var-get_poly_basis' class='documenter-example-output'><code class='code-output'>get_poly_basis (generic function with 1 method)</code></pre>


<div class="markdown"><p>We are going to use the canonical basis to determine a <strong>poised set</strong> of points. This does in fact work with any polynomial basis for <span class="tex">$Π_n^d$</span>. <br />In the process of doing so, we also modify &#40;a copy of?&#41; the basis so that it becomes the Lagrange basis for the returned point set.</p>
</div>


<div class="markdown"><p>The Larange basis is formed by normalizing and orthogonalizing with respect to the point set:</p>
</div>

<pre class='language-julia'><code class='language-julia'>function orthogonalize_polys( poly_arr, x, i )
	# normalize i-th polynomial with respect to `x`
	p_i = poly_arr[i] / poly_arr[i](x)
	
	# orthogoalize 
	return [ j != i ? poly_arr[j] - poly_arr[j](x) * p_i : p_i for j = eachindex( poly_arr ) ]
end</code></pre>
<pre id='var-orthogonalize_polys' class='documenter-example-output'><code class='code-output'>orthogonalize_polys (generic function with 1 method)</code></pre>


<div class="markdown"><p>We use Algorithm 6.2 and Algorithm 6.3 from the book  &quot;Introduction to Derivative-Free Optimization&quot; by Conn et. al. <br />Algorithm 6.2 makes the set poised &#40;suited for interpolation&#41; and returns the corresponding Lagrange basis. Algorithm 6.3 takes the poised set and the Lagrange basis and tries to make it <span class="tex">$Λ$</span>-poised. <span class="tex">$Λ$</span> must be greater 1 and a smaller value makes the set more suited for good models.</p>
</div>

<pre class='language-julia'><code class='language-julia'>"""
    get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )

Compute a point set suited for polynomial interpolation.

Input:
* `basis`: A vector of polynomials constituting a basis for the polynomial space.
* `points`: (optional) A set of candidate points to be tried for inclusion into the poised set.
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run. 

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`. 
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
"""
function get_poised_set( basis, points :: AbstractArray{T} = Vector{Float32}[]; 
		solver = :LN_BOBYQA, max_solver_evals = -1 ) where {
		T &lt;: AbstractArray{&lt;:Real}
	}
	
	p = length(basis)
	@assert p &gt; 0 "`basis` must not be an empty array."

	vars = variables( basis[end] )
	n_vars = length(vars)
	@assert n_vars &gt; 0 "The number of variables must be positive."
	
	if max_solver_evals &lt; 0
		max_solver_evals = 2000 * n_vars
	end

	F = promote_type( eltype( T ), Float32 )
	P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}
	ZERO_TOL = min(eps(F) * 100, eps(Float16) * 10)
	
	# indicates which points from points have been accepted
	point_indices = fill(-1, p)
	not_accepted_indices = collect( eachindex( points ) )
	# return array of points that form a poised set
	poised_points = P_type(undef, p)
		
	new_basis = basis
	for i = 1 : p
		_points = points[not_accepted_indices]
		
		# find the point that maximizes the i-th polynomial 
		# if the polynomial is constant, then the first remaining point is used (j = 1)
		l_max, j = if isempty(_points)
			0.0, 0
		else
			findmax( abs.( [ new_basis[i]( x ) for x in _points ] ) )
		end
		
		if l_max &gt; ZERO_TOL
			# accept the `j`-th point from `_points`
			poised_points[i] = _points[j]
			## indicate what the actual point index was  
			point_indices[i] = not_accepted_indices[j]
			## delete from further consideration
			deleteat!(not_accepted_indices, j)
		else
			# no point was suitable to add to the set
			# trying to find the maximizer for a | l_i(x) |
			opt = NLopt.Opt( solver, n_vars ) 
			opt.lower_bounds = zeros(F, n_vars )
            opt.upper_bounds = ones(F, n_vars )
            opt.maxeval = max_solver_evals
            opt.xtol_rel = 1e-3
            opt.max_objective = (x,g) -&gt; abs( new_basis[i](x) )
			
			x₀_tmp = [ rand(F, n_vars) for i = 1 : 50 * n_vars ]
            x₀ = x₀_tmp[argmax( abs.(new_basis[i].(x₀_tmp)) ) ] 
            
			_, ξ, ret = NLopt.optimize(opt, x₀)
			
			poised_points[i] = ξ
		end		
		
		new_basis = orthogonalize_polys( new_basis, poised_points[i], i )
	end
	
	return poised_points, new_basis, point_indices
end
			</code></pre>


<pre class='language-julia'><code class='language-julia'>"""
    make_set_lambda_poised( basis, points; 
        LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )

Make the output of `get_poised_set` even better suited for interpolation.

Input:
* `basis`: A vector of polynomials constituting a Lagrange basis for the polynomial space.
* `points`: The vector of points belonging to the Lagrange basis.
* `LAMBDA :: Real &gt; 1`: Determines the quality of the interpolation. 
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run. 
* `max_loops`: Maximum number of loops that try to make the set Λ-poised.
* `skip_indices`: Inidices of points to discard last.

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`. 
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
"""
function make_set_lambda_poised( basis, points :: AbstractArray{T}; 
		LAMBDA :: Real = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1,
		max_loops = -1, skip_indices = [1,] ) where {
		T &lt;: AbstractArray{&lt;:Real}
	}
	
	@assert length(basis) == length(points) "Polynomial array `basis` and point array `points` must have the same length."
	
	if length(points) &gt; 0
		n_vars = length(points[1])
		@assert n_vars &gt; 0 "The number of variables must be positive."
		
		F = promote_type( eltype( T ), Float32 )
		P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}

		if max_loops &lt; 0 
			max_loops = length(basis) * 100
		end

		if max_solver_evals &lt; 0
			max_solver_evals = 2000 * n_vars
		end

		new_basis = basis
		new_points = P_type(points)
		point_indices = collect(eachindex(new_points))

		for k = 1 : max_loops
			iₖ = -1
			xₖ = points[1]
			for (i, polyᵢ) in enumerate(new_basis)
				opt = NLopt.Opt( solver, n_vars )
				opt.lower_bounds = zeros(F, n_vars)
				opt.upper_bounds = ones(F, n_vars)
				opt.maxeval = max_solver_evals
				opt.xtol_rel = 1e-3
				opt.max_objective = (x,g) -&gt; abs( polyᵢ( x ) ) 

				x₀_tmp = [ rand(F, n_vars) for i = 1 : 50 * n_vars ]
				x₀ = x₀_tmp[argmax( abs.(new_basis[i].(x₀_tmp)) ) ] 

				abs_lᵢ, xᵢ, _ = NLopt.optimize(opt, x₀)

				if abs_lᵢ &gt; LAMBDA
					iₖ = i
					xₖ = xᵢ
					if i ∉ skip_indices
						# i is not prioritized we can brake here
						break
					end#if
				end#if
			end#for

			if iₖ &gt; 0
				# perform a point swap
				new_points[iₖ] = xₖ
				point_indices[iₖ] = -1
				# adapt coefficients of lagrange basis
				new_basis = orthogonalize_polys( new_basis, xₖ, iₖ )
			else
				# we are done, the set is lambda poised
				break
			end#if
		end#for

		return new_points, new_basis, point_indices
	else
		return points, basis, collect(eachindex(points))
	end
	
end</code></pre>



<div class="markdown"><p>For the sake of convenience we combine both functions:</p>
</div>

<pre class='language-julia'><code class='language-julia'>function get_lambda_poised_set( basis, points; solver1 = :LN_BOBYQA, solver2 = :LN_BOBYQA, max_solver_evals1 = -1, max_solver_evals2 = -1, LAMBDA = 1.5, max_lambda_loops = -1 )
	lagrange_points, lagrange_basis, lagrange_indices = get_poised_set( 
		basis, points; solver = solver1, max_solver_evals = max_solver_evals1 )
	lambda_points, lambda_basis, lambda_indices = make_set_lambda_poised( 
		lagrange_basis, lagrange_points; LAMBDA, max_loops = max_lambda_loops,
		solver = solver2, max_solver_evals = max_solver_evals2 )
	combined_indices = [ i &lt; 0 ? i : lagrange_indices[j] for (j,i) in enumerate( lambda_indices ) ]
	return lambda_points, lambda_basis, combined_indices
end</code></pre>
<pre id='var-get_lambda_poised_set' class='documenter-example-output'><code class='code-output'>get_lambda_poised_set (generic function with 1 method)</code></pre>


<div class="markdown"><p>Let&#39;s have a look at what the points look like:</p>
</div>

<pre class='language-julia'><code class='language-julia'>begin 
	basis = get_poly_basis(2,2)
	custom_points =  [ ones(Float32, 2), ones(Float32,2)] 
	
	#lambda_points, lambda_basis, c_indices = get_lambda_poised_set( basis,custom_points)
	lambda_points, lambda_basis, c_indices = get_poised_set( basis,custom_points)
	c_indices
end</code></pre>
<pre id='var-lambda_points' class='documenter-example-output'><code class='code-output'>6-element Vector{Int64}:
  1
 -1
 -1
 -1
 -1
 -1</code></pre>

<pre class='language-julia'><code class='language-julia'>scatter(Tuple.(lambda_points))</code></pre>
<img src="data:image/png;base64,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">

<!-- PlutoStaticHTML.End --></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../notebook_finite_differences/">« Finite Differences</a><a class="docs-footer-nextpage" href="../../custom_logging/">Pretty Printing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Tuesday 1 March 2022 12:44">Tuesday 1 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
