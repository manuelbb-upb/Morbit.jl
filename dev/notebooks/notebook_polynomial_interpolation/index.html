<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lagrange Interpolation · Morbit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/notebooks/notebook_polynomial_interpolation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Morbit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../../constraints/">Constraints</a></li><li><a class="tocitem" href="../../composites/">Composite Functions</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li class="is-active"><a class="tocitem" href>Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../../dev_man/">DocStrings</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Random Notebooks</a></li><li class="is-active"><a href>Lagrange Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lagrange Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/main/docs/src/notebooks/notebook_polynomial_interpolation.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><style>
    table {
        display: table !important;
        margin: 2rem auto !important;
        border-top: 2pt solid rgba(0,0,0,0.2);
        border-bottom: 2pt solid rgba(0,0,0,0.2);
    }

    pre, div {
        margin-top: 1.4rem !important;
        margin-bottom: 1.4rem !important;
    }

    .code-output {
        padding: 0.7rem 0.5rem !important;
    }

    .admonition-body {
        padding: 0em 1.25em !important;
    }
</style>

<!-- PlutoStaticHTML.Begin -->
<!--
    # This information is used for caching.
    [PlutoStaticHTML.State]
    input_sha = "82012d577aa3f4c8a17e8ae42e5be8699cf7aae035a78d6f6e96e99bcbd777d2"
    julia_version = "1.6.6"
-->
<pre class='language-julia'><code class='language-julia'>begin
    import Pkg
    Pkg.activate(tempname())
    Pkg.add("DynamicPolynomials")
    Pkg.add("NLopt")
    Pkg.add("StaticArrays")
    Pkg.add("CairoMakie")
    Pkg.add("Makie")
    Pkg.add("Combinatorics")
    Pkg.add("BenchmarkTools")
end</code></pre>


<pre class='language-julia'><code class='language-julia'>begin
    using DynamicPolynomials
    using BenchmarkTools
    import NLopt
    using StaticArrays
    using Makie, CairoMakie
    using Combinatorics
end</code></pre>



<div class="markdown"><p>We denote by <span class="tex">$Π_n^d$</span> the space of <span class="tex">$n$</span>-variate Polyoniams of degree at most <span class="tex">$d$</span>. To construct polynomials we use <code>DynamicPolynomials.jl</code>.</p>
</div>


<div class="markdown"><p>The canonical basis is obtained by calculating the non-negative integral solutions to the euqation</p>
<p class="tex">$$x_1 &#43; … &#43; x_n \le d.$$</p>
</div>


<div class="markdown"><p>These solutions can be found using the <code>Combinatorics</code> package via <code>multiexponents&#40;n,d&#41;</code> &#40;<code>d</code> must be successively increased&#41;.</p>
</div>

<pre class='language-julia'><code class='language-julia'>function non_negative_ineq_solutions(deg, n_vars)
    collect(Iterators.flatten( ( collect(multiexponents( n_vars, d )) for d = 0 : deg ) ))
end</code></pre>
<pre id='var-non_negative_ineq_solutions' class='code-output documenter-example-output'>non_negative_ineq_solutions (generic function with 1 method)</pre>

<pre class='language-julia'><code class='language-julia'>function get_poly_basis( deg, n_vars)
    exponents = non_negative_ineq_solutions(deg, n_vars )
    polys = let
        @polyvar x[1:n_vars]
        [ prod(x.^e) for e in exponents ]
    end
    return polys
end</code></pre>
<pre id='var-get_poly_basis' class='code-output documenter-example-output'>get_poly_basis (generic function with 1 method)</pre>


<div class="markdown"><p>We are going to use the canonical basis to determine a <strong>poised set</strong> of points. This does in fact work with any polynomial basis for <span class="tex">$Π_n^d$</span>. <br />In the process of doing so, we also modify &#40;a copy of?&#41; the basis so that it becomes the Lagrange basis for the returned point set.</p>
</div>


<div class="markdown"><p>The Larange basis is formed by normalizing and orthogonalizing with respect to the point set:</p>
</div>

<pre class='language-julia'><code class='language-julia'>function orthogonalize_polys( poly_arr, x, i )
    # normalize i-th polynomial with respect to `x`
    p_i = poly_arr[i] / poly_arr[i](x)
    
    # orthogoalize 
    return [ j != i ? poly_arr[j] - poly_arr[j](x) * p_i : p_i for j = eachindex( poly_arr ) ]
end</code></pre>
<pre id='var-orthogonalize_polys' class='code-output documenter-example-output'>orthogonalize_polys (generic function with 1 method)</pre>


<div class="markdown"><p>We use Algorithm 6.2 and Algorithm 6.3 from the book  &quot;Introduction to Derivative-Free Optimization&quot; by Conn et. al. <br />Algorithm 6.2 makes the set poised &#40;suited for interpolation&#41; and returns the corresponding Lagrange basis. Algorithm 6.3 takes the poised set and the Lagrange basis and tries to make it <span class="tex">$Λ$</span>-poised. <span class="tex">$Λ$</span> must be greater 1 and a smaller value makes the set more suited for good models.</p>
</div>

<pre class='language-julia'><code class='language-julia'>"""
    get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )

Compute a point set suited for polynomial interpolation.

Input:
* `basis`: A vector of polynomials constituting a basis for the polynomial space.
* `points`: (optional) A set of candidate points to be tried for inclusion into the poised set.
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run. 

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`. 
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
"""
function get_poised_set( basis, points :: AbstractArray{T} = Vector{Float32}[]; 
        solver = :LN_BOBYQA, max_solver_evals = -1 ) where {
        T &lt;: AbstractArray{&lt;:Real}
    }
    
    p = length(basis)
    @assert p &gt; 0 "`basis` must not be an empty array."

    vars = variables( basis[end] )
    n_vars = length(vars)
    @assert n_vars &gt; 0 "The number of variables must be positive."
    
    if max_solver_evals &lt; 0
        max_solver_evals = 2000 * n_vars
    end

    F = promote_type( eltype( T ), Float32 )
    P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}
    ZERO_TOL = min(eps(F) * 100, eps(Float16) * 10)
    
    # indicates which points from points have been accepted
    point_indices = fill(-1, p)
    not_accepted_indices = collect( eachindex( points ) )
    # return array of points that form a poised set
    poised_points = P_type(undef, p)
        
    new_basis = basis
    for i = 1 : p
        _points = points[not_accepted_indices]
        
        # find the point that maximizes the i-th polynomial 
        # if the polynomial is constant, then the first remaining point is used (j = 1)
        l_max, j = if isempty(_points)
            0.0, 0
        else
            findmax( abs.( [ new_basis[i]( x ) for x in _points ] ) )
        end
        
        if l_max &gt; ZERO_TOL
            # accept the `j`-th point from `_points`
            poised_points[i] = _points[j]
            ## indicate what the actual point index was  
            point_indices[i] = not_accepted_indices[j]
            ## delete from further consideration
            deleteat!(not_accepted_indices, j)
        else
            # no point was suitable to add to the set
            # trying to find the maximizer for a | l_i(x) |
            opt = NLopt.Opt( solver, n_vars ) 
            opt.lower_bounds = zeros(F, n_vars )
            opt.upper_bounds = ones(F, n_vars )
            opt.maxeval = max_solver_evals
            opt.xtol_rel = 1e-3
            opt.max_objective = (x,g) -&gt; abs( new_basis[i](x) )
            
            x₀_tmp = [ rand(F, n_vars) for i = 1 : 50 * n_vars ]
            x₀ = x₀_tmp[argmax( abs.(new_basis[i].(x₀_tmp)) ) ] 
            
            _, ξ, ret = NLopt.optimize(opt, x₀)
            
            poised_points[i] = ξ
        end		
        
        new_basis = orthogonalize_polys( new_basis, poised_points[i], i )
    end
    
    return poised_points, new_basis, point_indices
end
            </code></pre>


<pre class='language-julia'><code class='language-julia'>"""
    make_set_lambda_poised( basis, points; 
        LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )

Make the output of `get_poised_set` even better suited for interpolation.

Input:
* `basis`: A vector of polynomials constituting a Lagrange basis for the polynomial space.
* `points`: The vector of points belonging to the Lagrange basis.
* `LAMBDA :: Real &gt; 1`: Determines the quality of the interpolation. 
* `solver`: NLopt solver to use. Should be derivative-free.
* `max_solver_evals`: Maximum number of evaluations in each optimization run. 
* `max_loops`: Maximum number of loops that try to make the set Λ-poised.
* `skip_indices`: Inidices of points to discard last.

Return:
* `poised_points :: Vector{T}` where `T` is either a `Vector{F}` or an `SVector{n_vars, F}` and `F` is the precision of the points in `points`, but at least `Float32`. 
* `lagrange_basis :: Vector{&lt;:AbstractPolynomialLike}`: The Lagrange basis corresponding to `poised_points`.
* `point_indices`: An array indicating which points from `points` are also in `poised_points`. A positive entry corresponds to the index of a poised point in `points`. If a poised point is new, then the entry is `-1`.
"""
function make_set_lambda_poised( basis, points :: AbstractArray{T}; 
        LAMBDA :: Real = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1,
        max_loops = -1, skip_indices = [1,] ) where {
        T &lt;: AbstractArray{&lt;:Real}
    }
    
    @assert length(basis) == length(points) "Polynomial array `basis` and point array `points` must have the same length."
    
    if length(points) &gt; 0
        n_vars = length(points[1])
        @assert n_vars &gt; 0 "The number of variables must be positive."
        
        F = promote_type( eltype( T ), Float32 )
        P_type = n_vars &gt; 100 ? Vector{Vector{F}} : Vector{SVector{n_vars, F}}

        if max_loops &lt; 0 
            max_loops = length(basis) * 100
        end

        if max_solver_evals &lt; 0
            max_solver_evals = 2000 * n_vars
        end

        new_basis = basis
        new_points = P_type(points)
        point_indices = collect(eachindex(new_points))

        for k = 1 : max_loops
            iₖ = -1
            xₖ = points[1]
            for (i, polyᵢ) in enumerate(new_basis)
                opt = NLopt.Opt( solver, n_vars )
                opt.lower_bounds = zeros(F, n_vars)
                opt.upper_bounds = ones(F, n_vars)
                opt.maxeval = max_solver_evals
                opt.xtol_rel = 1e-3
                opt.max_objective = (x,g) -&gt; abs( polyᵢ( x ) ) 

                x₀_tmp = [ rand(F, n_vars) for i = 1 : 50 * n_vars ]
                x₀ = x₀_tmp[argmax( abs.(new_basis[i].(x₀_tmp)) ) ] 

                abs_lᵢ, xᵢ, _ = NLopt.optimize(opt, x₀)

                if abs_lᵢ &gt; LAMBDA
                    iₖ = i
                    xₖ = xᵢ
                    if i ∉ skip_indices
                        # i is not prioritized we can brake here
                        break
                    end#if
                end#if
            end#for

            if iₖ &gt; 0
                # perform a point swap
                new_points[iₖ] = xₖ
                point_indices[iₖ] = -1
                # adapt coefficients of lagrange basis
                new_basis = orthogonalize_polys( new_basis, xₖ, iₖ )
            else
                # we are done, the set is lambda poised
                break
            end#if
        end#for

        return new_points, new_basis, point_indices
    else
        return points, basis, collect(eachindex(points))
    end
    
end</code></pre>



<div class="markdown"><p>For the sake of convenience we combine both functions:</p>
</div>

<pre class='language-julia'><code class='language-julia'>function get_lambda_poised_set( basis, points; solver1 = :LN_BOBYQA, solver2 = :LN_BOBYQA, max_solver_evals1 = -1, max_solver_evals2 = -1, LAMBDA = 1.5, max_lambda_loops = -1 )
    lagrange_points, lagrange_basis, lagrange_indices = get_poised_set( 
        basis, points; solver = solver1, max_solver_evals = max_solver_evals1 )
    lambda_points, lambda_basis, lambda_indices = make_set_lambda_poised( 
        lagrange_basis, lagrange_points; LAMBDA, max_loops = max_lambda_loops,
        solver = solver2, max_solver_evals = max_solver_evals2 )
    combined_indices = [ i &lt; 0 ? i : lagrange_indices[j] for (j,i) in enumerate( lambda_indices ) ]
    return lambda_points, lambda_basis, combined_indices
end</code></pre>
<pre id='var-get_lambda_poised_set' class='code-output documenter-example-output'>get_lambda_poised_set (generic function with 1 method)</pre>


<div class="markdown"><p>Let&#39;s have a look at what the points look like:</p>
</div>

<pre class='language-julia'><code class='language-julia'>begin 
    basis = get_poly_basis(2,2)
    custom_points =  [ ones(Float32, 2), ones(Float32,2)] 
    
    #lambda_points, lambda_basis, c_indices = get_lambda_poised_set( basis,custom_points)
    lambda_points, lambda_basis, c_indices = get_poised_set( basis,custom_points)
    c_indices
end</code></pre>
<pre id='var-lambda_points' class='code-output documenter-example-output'>6-element Vector{Int64}:
  1
 -1
 -1
 -1
 -1
 -1</pre>

<pre class='language-julia'><code class='language-julia'>scatter(Tuple.(lambda_points))</code></pre>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAJYCAIAAAAVFBUnAAAABmJLR0QA/wD/AP+gvaeTAAAckElEQVR4nO3df3CV9b3g8eecJAYh4YcYCZbkJpRS4K4Vtt5S9xZoTe+M13Ymw9wZy4zX2bV0+TG1Fn/P9i5b2N66s+rYXh2sQOTKrLst3dkZi2NHb7OXXgvplHEt2o5eIGgQNFECIST8CCQ5+0dqBhGQEz4n5xBer7/I93xPnk90Tp73POdJkspkMgkAAHHS+R4AAGCkEVgAAMEEFgBAMIEFABBMYAEABBNYAADBBBYAQDCBBQAQTGABAAQTWAAAwQQWAEAwgQUAEExgAQAEE1gAAMGK8z3AR/z4xz/esWNHTU1NvgcBAPiTlpaW2bNnr1ix4sKfUlhXsHbs2NHS0pLTQ2QymSNHjuT0EEAh6Onp6enpyfcUQM4dOXIkk8nk9BAtLS07duzI6imFdQWrpqampqZm1apVuTtEJpPZv39/VVVV7g4BFILOzs4kScaNG5fvQYDc2rdv35QpU1KpVO4OMYQyKawrWAAAI4DAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYEMPrF27du3YseP8e/bs2fPiiy++//77Qz4KAMAlZ+iBdf/99z/77LPnerSnp6e+vn7atGkLFy6srKxcuXLlkA8EAHBpKc72CceOHduxY8dPf/rTzZs333vvvefatnr16i1btjQ1Nc2dO3fjxo2LFy++4YYb6uvrL27ai3L0ZN+P/uWtf25u33PgyPRJ794y85pv/2XNFUXeJAWAS8/Jvv4121p++eYHu97v/HTF/pumXX33gqljrijK91x/knVgbd68+c4770ySJJ0+Z5r09fU988wzS5cuvfHGG5MkueOOOzZu3Lhhw4Y8BlbH8VNfXtP0euuRgQ/f6TzQuOvAc39oe3HJ3CtLCuV/BgBwIY6f6rt53e9efuvgwIfvdLZvaW7/36+99+tv/7sJV5bkd7YBWV+/WbRoUXt7e3t7e21t7bn27N27t7W1ta6ubnClrq6uqalpiDNG+P6LOwfratDLbx380ctv5WUeAGDIfvTyW4N1Nej11iPff3FnXub5uJy8QdbW1pYkyaRJkwZXKisrDx482Nvbm4vDXYhNO9476/rPz7EOABSsTb8/x2n9tUI5rWf9FuGFOHz4cJIk5eXlgyvl5eWZTKajo6OiomJw8dFHH33kkUdOf+L1119/3XXXvfvuu7HznOrPfNDdc9aH9h46Gn44oBB0dXUlSdLd3Z3vQYB473QcPev6+109Lfv2l6RTsYfr6uo6vWouRE4Ca+LEicmH390GdHZ2plKp8ePHn75t+fLlt99+++krjz/+eHFxcWVlZfhI5aV/6Oo5y/Wza8pH5eJwQN5deeWVSZKMGzcu34MA8SrKdh4+cZbGGjuquOrayeGHKysry/YpOQmsgWQZeKNwQFtbW0VFRUnJR+47GzNmzJgxY05fGdhQVBR/1/nXZk362e/PcqXqlpmTcnE4IO8GXtpe4DAifW3WpB+f7S7qHJ3WU6msL4nl5B6s6urq2traxsbGwZXGxsb58+fn4lgX6KFbZlSUXXHGYu1Vo//uq5/JyzwAwJB9r+4ztVeNPmOxouyKh26ZkZd5Pi4ysNatW7do0aKenp5UKrVkyZK1a9du3bq1t7d3/fr127ZtW758eeCxslV71ejt35136+xrrxpdkiTJNWWld3yh6rd3fenqMWdWFwBQ4CrKrvjtXV+64wtV15SVJkly1eiSW2dfu/278z5eXfkS+Rbh9u3bN23a1NDQUFpa+sADD7S0tCxYsKCoqCidTq9Zs+amm24KPNYQ1Fw1etPtn89kMrvefuezU/8sv8MAABdjUnnphm/MTpJk51t7p9dWD+FdvJwaemA1NzefsdLQ0NDQ0DDw73Q6/dRTTz388MN79uyZNWtWaWnp0GeMNrrEb28HgBGiME/rObnJfdDYsWPnzJmT00MAABSaQow+AIBLmsACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGDF+R4AICdO9fXnewTg8iWwgJHmf/y//T/6l7f+2NaVJMm/qSy/Z8HUv/38lHwPBVxeBBYwovzXf9r1/Zd2Dn74+3c7b/9fv3/70LGVfzU9j1MBlxv3YAEjx96O43/fuPvj6z/41e69HceHfx7gsiWwgJHjpZ0fnPXWq1N9/f+084Phnwe4bAksYOQ4ePTkuR5qP/dDAOEEFjByfGrcled6aMr4cz4EEE5gASPHLTOvKS89y8/ulJcW//WMa4Z/HuCyJbCAkePqMVc8+TfXFaVTpy8WpVNP/s11V4+5Il9TAZchv6YBGFH+9vNTPlMx5vHfvP3qvo4kSf5t1YTvzpv6herx+Z4LuLwILGCkmVs94X/eNqGzszNJknHjxuV7HOBy5C1CAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsAIJjAAgAIJrAAAIIJLACAYAILACCYwAIACCawAACCCSwAgGACCwAgmMACAAgmsAAAggksAIBgAgsA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">

<!-- PlutoStaticHTML.End --></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../notebook_finite_differences/">« Finite Differences</a><a class="docs-footer-nextpage" href="../../custom_logging/">Pretty Printing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 17 May 2022 13:16">Tuesday 17 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
