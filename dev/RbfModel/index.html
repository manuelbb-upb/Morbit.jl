<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RbfModels · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/RbfModel/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../example_zdt/">ZDT3</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li class="is-active"><a class="tocitem" href>RbfModels</a><ul class="internal"><li><a class="tocitem" href="#Intro-and-Prerequisites"><span>Intro and Prerequisites</span></a></li><li><a class="tocitem" href="#Surrogate-Interface-Implementations"><span>Surrogate Interface Implementations</span></a></li><li><a class="tocitem" href="#Construction"><span>Construction</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Summary-and-Quick-Examples"><span>Summary &amp; Quick Examples</span></a></li></ul></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../dev_man/">DocStrings</a></li><li><a class="tocitem" href="../Interfaces/">Interfaces</a></li><li><a class="tocitem" href="../AbstractResultInterface/"><code>AbstractResult</code> Interface</a></li><li><a class="tocitem" href="../AbstractIterDataInterface/"><code>AbstractIteraData</code> Interface</a></li><li><a class="tocitem" href="../AbstractDBInterface/"><code>AbstractDB</code> Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Models</a></li><li class="is-active"><a href>RbfModels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RbfModels</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/master/src/RbfModel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Radial-Basis-Function-Surrogate-Models"><a class="docs-heading-anchor" href="#Radial-Basis-Function-Surrogate-Models">Radial Basis Function Surrogate Models</a><a id="Radial-Basis-Function-Surrogate-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-Basis-Function-Surrogate-Models" title="Permalink"></a></h1><h2 id="Intro-and-Prerequisites"><a class="docs-heading-anchor" href="#Intro-and-Prerequisites">Intro and Prerequisites</a><a id="Intro-and-Prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Intro-and-Prerequisites" title="Permalink"></a></h2><p>We want to offer radial basis function (RBF) surrogate models (implementing the <code>SurrogateModel</code> interface). To this end, we leverage the package <a href="https://github.com/manuelbb-upb/RadialBasisFunctionModels.jl"><code>RadialBasisFunctionModels.jl</code></a>. A scalar RBF model consists of a <span>$n$</span>-variate Polynomial and linear combination of shifted radial kernels. For more information, see <a href="https://manuelbb-upb.github.io/RadialBasisFunctionModels.jl/stable">the documentation of <code>RadialBasisFunctionModels.jl</code></a>.</p><pre><code class="language-julia hljs">import RadialBasisFunctionModels as RBF
using LinearAlgebra: qr, Hermitian, cholesky, inv, I, givens, diag</code></pre><p>The polyonmials will have a degree of at most 1. To construct “good” linear polynomials, we need to make sure to have construction sites, that span the decision space well. Such a set of construction sites is called Λ-poised or sufficiently affinely independent. The file <code>AffinelyIndependentPoints</code> implements some helpers to find suitable points as described by Wild et. al.<sup class="footnote-reference"><a id="citeref-wild_diss" href="#footnote-wild_diss">[wild_diss]</a></sup></p><pre><code class="language-julia hljs">include(&quot;AffinelyIndependentPoints.jl&quot;)</code></pre><h2 id="Surrogate-Interface-Implementations"><a class="docs-heading-anchor" href="#Surrogate-Interface-Implementations">Surrogate Interface Implementations</a><a id="Surrogate-Interface-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-Interface-Implementations" title="Permalink"></a></h2><p>The model used in our algorithm simply wraps an interpolation model from the <code>RBF</code> package.</p><pre><code class="language-julia hljs">@with_kw struct RbfModel{R} &lt;: SurrogateModel
	model :: R

	# indicator: is the model fully linear?
	fully_linear :: Bool = false
end

fully_linear( rbf :: RbfModel ) :: Bool = rbf.fully_linear</code></pre><p>We offer a large range of configuration parameters in the <code>RBFConfig</code>, which implements a <code>SurrogateConfig</code>.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    RbfConfig(; kwarg1 = val1, … )

Configuration type for local RBF surrogate models.

To choose a kernel, use the kwarg `kernel` and a value of either
`:cubic` (default), `:inv_multiquadric`, `:multiquadric`, `:gaussian` or `:thin_plate_spline`.
The kwarg `shape_parameter` takes a constant number or a string
that defines a calculation on `Δ`, e.g, &quot;Δ/10&quot;.
Note, that `shape_parameter` has a different meaning for the different kernels.
For ``:gaussian, :inv_multiquadric, :multiquadric` it actually is a floating point shape_parameter.
For :cubic it is the (odd) integer exponent and for `thin_plate_spline` it is an integer exponent as well.
Use `NaN` for defaults.

To see other configuration parameters use `fieldnames(Morbit.RbfConfig)`.
They have individual docstrings attached.
&quot;&quot;&quot;
@with_kw mutable struct RbfConfig &lt;: SurrogateConfig
    &quot;(default `:cubic`) RBF kernel (Symbol), either `:cubic`, `:multiquadric`, `:exp` or `:thin_plate_spline`.&quot;
    kernel :: Symbol = :cubic

	&quot;(default `1`) RBF shape paremeter, either a number or a string containing `Δ`.&quot;
    shape_parameter :: Union{String, Float64} = NaN

	&quot;(default `1`) Degree of polynomial attached to RBF. `-1` means no polynomial.&quot;
    polynomial_degree :: Int64 = 1;

    &quot;(default `2`) Local enlargment factor of trust region for sampling.&quot;
    θ_enlarge_1 :: Float64 = 2

	&quot;(default `5`) Maximum enlargment factor of maximum trust region for sampling.&quot;
    θ_enlarge_2 :: Float64 = 2

	&quot;(default `1/(2*θ_enlarge_1)` Sampling parameter to generate Λ-poised set. The higher, the more poised.&quot;
    θ_pivot :: Float64 = 1 / (2 * θ_enlarge_1)

	&quot;(default `1e-7`) Parameter for 2nd sampling algorithm to ensure boundedness of Cholesky factors.&quot;
    θ_pivot_cholesky :: Float64 = 1e-7

    &quot;(default `false`) Require models to be fully linear in each iteration.&quot;
    require_linear :: Bool = false

    &quot;(default `-1`) Maximum number of training sites. `-1` is reset to `2n+1`.&quot;
    max_model_points :: Int64 = -1 # is probably reset in the algorithm
    &quot;(default `false`) Sample new sites to always use the maximum number of points.&quot;
    use_max_points :: Bool = false

	&quot;Whether or not to re-construct the training set in each iteration.&quot;
	optimized_sampling = true

#    &quot;(default `:orthogonal`) Algorithm to use for finding affinely independent set.&quot;
#    sampling_algorithm :: Symbol = :orthogonal # :orthogonal or :monte_carlo

##	&quot;(default `:standard_rand`) Algorithm to use if additional points are required.&quot;
#    sampling_algorithm2 :: Symbol = :standard_rand

    &quot;(default `typemax(Int64)`) Maximum number of objective evaluations.&quot;
    max_evals :: Int64 = typemax(Int64)

	@assert θ_enlarge_1 * θ_pivot ≤ 1 &quot;θ_pivot must be &lt;= θ_enlarge_1^(-1).&quot;

##	@assert sampling_algorithm ∈ [:orthogonal, :monte_carlo] &quot;Sampling algorithm must be either `:orthogonal` or `:monte_carlo`.&quot;
    @assert kernel ∈ Symbol.([&quot;gaussian&quot;, &quot;inv_multiquadric&quot;, &quot;multiquadric&quot;, &quot;cubic&quot;, &quot;thin_plate_spline&quot;]) &quot;Kernel &#39;$kernel&#39; not supported yet.&quot;
	# Some sanity checks for the shape parameters
    @assert kernel != :thin_plate_spline || ( isnan(shape_parameter) || shape_parameter % 1 == 0 &amp;&amp; shape_parameter &gt;= 1 ) &quot;Invalid shape_parameter for :thin_plate_spline.&quot;
	@assert kernel != :cubic || ( isnan(shape_parameter) || shape_parameter % 1 == 0 &amp;&amp; shape_parameter % 2 == 1 ) &quot;Invalid shape_parameter for :cubic.&quot;
	@assert (isa( shape_parameter, String ) || isnan(shape_parameter)) || shape_parameter &gt; 0 &quot;Shape parameter must be strictly positive.&quot;
    # @assert θ_enlarge_1 &gt;=1 &amp;&amp; θ_enlarge_2 &gt;=1 &quot;θ&#39;s must be &gt;= 1.&quot;
end</code></pre><p>The required method implementations are straightforward. Note, thate we allow the models to be combined to vector functions if they share the same configuration to avoid redundant efforts whilst constructing models.</p><pre><code class="language-julia hljs">max_evals( cfg :: RbfConfig ) :: Int = cfg.max_evals
combinable( cfg :: RbfConfig ) :: Bool = true
combine(cfg1 :: RbfConfig, :: RbfConfig) :: RbfConfig = cfg1</code></pre><p>We also need to introduce our own implementation for <code>isequal</code> and <code>hash</code> for <code>RbfConfig</code>s to be combinable, see <a href="https://docs.julialang.org/en/v1/base/base/">the docs too</a>.</p><pre><code class="language-julia hljs">function Base.hash( cfg :: RbfConfig, h :: UInt )
	return hash( getfield.( cfg, Tuple( fn for fn ∈ fieldnames(RbfConfig) ) ), h )
end
function Base.isequal( cfg1 :: RbfConfig, cfg2 :: RbfConfig )
	all( isequal( getfield(cfg1, fn), getfield(cfg2, fn) ) for fn in fieldnames( RbfConfig) )
end</code></pre><p>To allow the user to set the shape parameter relative to the current trust region radius using a verbose string, we need this little helper function, which evaluates the string.</p><pre><code class="language-julia hljs">function parse_shape_param_string( Δ :: F, expr_str) :: F where F
    ex = Meta.parse(expr_str)
    sp = @eval begin
        let Δ=$Δ
            $ex
        end
    end
	return sp
end</code></pre><p>The <code>RbfMeta</code> is used to store construction and update data for the models. To be specific, we have several inidices lists that store database indices of (potentially unevaluated) results that are later used for fitting the model.</p><pre><code class="language-julia hljs">@with_kw mutable struct RbfMeta{F&lt;:AbstractFloat} &lt;: SurrogateMeta
    center_index :: Int = -1
    round1_indices :: Vector{Int} = []
    round2_indices :: Vector{Int} = []
    round3_indices :: Vector{Int} = []
    round4_indices :: Vector{Int} = []
    fully_linear :: Bool = false
	improving_directions :: Vector{Vector{F}} = []
end


get_saveable_type( meta :: T ) where {T&lt;:RbfMeta} = T
get_saveable( meta :: RbfMeta ) = deepcopy(meta)</code></pre><p>A little helper to retrieve all those indices:</p><pre><code class="language-julia hljs">function _collect_indices( meta :: RbfMeta; include_x = true ) :: Vector{Int}
	return [
		include_x ? meta.center_index : [];
		meta.round1_indices;
		meta.round2_indices;
		meta.round3_indices;
		meta.round4_indices
	]
end</code></pre><p>And a helper, to partially copy some data from <code>src</code> to <code>dest</code>. This is due to the fact, that the first 3 rounds of construction data gathering are the same for all possible RBF models and we can safe some effort.</p><pre><code class="language-julia hljs">function copy_meta!(dest, src)
	dest.center_index = src.center_index
	for fn in [ Symbol(&quot;round$(i)_indices&quot;) for i = 1: 3 ]
		dest_arr = getfield(dest, fn)
		empty!( dest_arr )
		append!( dest_arr, getfield( src, fn) )
	end
	empty!(dest.improving_directions)
	append!(dest.improving_directions, src.improving_directions)
end

export RbfConfig, RbfMeta, RbfModel</code></pre><h2 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h2><p>The initial <code>prepare_init_model</code> function should return a meta object that can be used to build an initial surrogate model. We delegate the work to <code>prepare_update_model</code>.</p><pre><code class="language-julia hljs">function prepare_init_model( cfg :: RbfConfig, objf :: AbstractObjective, mop :: AbstractMOP,
	id :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig;
	ensure_fully_linear = true, kwargs...)
	F = eltype( get_x(id) )
	meta = RbfMeta{F}()
	return prepare_update_model(nothing, objf, meta, mop, id, db, ac; ensure_fully_linear = true, kwargs... )
end</code></pre><p>Usually, <code>prepare_update_model</code> would only accept a model as its first argument. Because of the trick from above, we actually allow <code>nothing</code>, too.</p><pre><code class="language-julia hljs">function prepare_update_model( mod :: Union{Nothing, RbfModel}, objf :: AbstractObjective, meta :: RbfMeta,
	mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, algo_config :: AbstractConfig;
	ensure_fully_linear = false, force_rebuild = false, meta_array = nothing )

	!force_rebuild &amp;&amp; @logmsg loglevel2 &quot;Trying to find results for fitting an RBF model.&quot;

	# Retrieve current iteration information and some meta data.
	Δ = get_delta(iter_data)
	Δ_max = get_delta_max(algo_config)
	x = get_x(iter_data)
	x_index = get_x_index(iter_data)
	cfg = model_cfg( objf )

	F = eltype(x)
	n_vars = length(x)

	# Can we skip the first rounds? (Because we already found interpolation sets for other RBFModels?)
	all_objfs = list_of_objectives(mop)
	skip_first_rounds = false
	for (i,other_meta) in enumerate(meta_array)
		other_objf = all_objfs[i]
		if other_meta isa RbfMeta
			other_cfg = model_cfg(other_objf)
			if other_cfg.θ_pivot == cfg.θ_pivot &amp;&amp; other_cfg.θ_enlarge_1 == cfg.θ_enlarge_1 &amp;&amp;
				other_cfg.θ_enlarge_2 == cfg.θ_enlarge_2 &amp;&amp; other_cfg.optimized_sampling == cfg.optimized_sampling
				copy_meta!( meta, other_meta )
				skip_first_rounds = true
			end
		end
	end

	# By default, assume that our model is not fully linear
	meta.fully_linear = false

	# use center as first training site ⇒ at least `n_vars` required still
	meta.center_index = x_index

	# First round of sampling:
	### Try to find points in slightly enlarged trust region
	Δ_1 = F.(cfg.θ_enlarge_1 * Δ)
	lb_1, ub_1 = local_bounds( mop, x, Δ_1 )
	piv_val_1 = F.(cfg.θ_pivot * Δ_1) # threshold value for acceptance in filter

	### `Δ_2` is the maximum allowed trust region radius and used in rounds 2 &amp; 4
	Δ_2 = F.(cfg.θ_enlarge_2 * Δ_max )
	lb_2, ub_2 = local_bounds( mop, x, Δ_2 )
	piv_val_2 = piv_val_1 # the pivot value stays the same

	skip_first_rounds &amp;&amp; @goto round4

	if force_rebuild || !cfg.optimized_sampling
		### `force_rebuild` makes us skip the point searching procedures to …
		### … rebuild the model along the coordinate axes.
		filtered_indices_1 = Int[]
		improving_directions = [ [zeros(F,i-1); one(F); zeros(F,n_vars - i)] for i = 1:n_vars ]
	else
		@logmsg loglevel3 &quot;Round1: Inspect box with radius $(Δ_1) and pivot value $(piv_val_1).&quot;

		### only consider points from within current trust region …
		candidate_indices_1 = results_in_box_indices( db, lb_1, ub_1, [x_index],)

		### … and filter them to obtain affinely independent points.
		filter = AffinelyIndependentPointFilter(;
			x_0 = x,
			seeds = get_site.(db, candidate_indices_1),
			return_indices = true,
			pivot_val = piv_val_1
		)

		filtered_indices_1 = candidate_indices_1[ collect( filter ) ]
		improving_directions = reverse(collect(Vector{F}, eachcol(filter.Z)))

		@logmsg loglevel3 &quot;Round1: Found $(length(filtered_indices_1)) sites in database.&quot;
	end
	### Store indices in meta data object:
	empty!(meta.round1_indices)
	append!(meta.round1_indices, filtered_indices_1)
	empty!(meta.improving_directions)
	append!(meta.improving_directions, improving_directions )

	# Second round of sampling:
	### If there are not enough sites to have a fully linear model …
	### … try to at least find more sites in maximum allowed radius
	n_missing = n_vars - length( meta.round1_indices )

	if n_missing == 0 || force_rebuild || !cfg.optimized_sampling || ensure_fully_linear || Δ ≈ Δ_max &amp;&amp; cfg.θ_enlarge_1 == cfg.θ_enlarge_2
		@logmsg loglevel3 &quot;Skipping round 2.&quot;

		meta.fully_linear = true
		filter_2 = filter
		empty!(meta.round2_indices)
	else
		### actually perform round 2

		@logmsg loglevel3 &quot;Missing $(n_missing) sites still.&quot;
		@logmsg loglevel3 &quot;Round2: Inspect box with radius $(Δ_2) and pivot value $(piv_val_1).&quot;

		### as before, only consider points in box of radius `Δ_2`, but ignore `x` and the previous points
		candidate_indices_2 = results_in_box_indices( db, lb_2, ub_2, [x_index; candidate_indices_1])

		filter_2 = AffinelyIndependentPointFilter(;
			x_0 = x,
			seeds = get_site.(db, candidate_indices_2),
			Y = filter.Y,	# pass prior matrices, so that new points are projected onto span of Z
			Z = filter.Z,
			n = n_missing,
			return_indices = true,
			pivot_val = piv_val_2
		)

		filtered_indices_2 = candidate_indices_2[ collect(filter_2) ]

		### Store indices
		empty!(meta.round2_indices)
		append!(meta.round2_indices, filtered_indices_2)

		@logmsg loglevel3 &quot;Round2: Found $(length(meta.round2_indices)) sites and model is $(meta.fully_linear ? &quot;&quot; : &quot;not &quot; )fully linear.&quot;
	end

	# Round 3:
	### If we still don&#39;t have enough sites, generate them
	### along model improving directions (from first round of sampling)

	n_missing -= length(meta.round2_indices)
	empty!(meta.round3_indices)
	if n_missing &gt; 0

		@logmsg loglevel3 &quot;Round3: Still missing $(n_missing). Sampling in box of radius $(Δ_1).&quot;

		### If round 2 did not yield any new points, the model will hopefully be made fully linear now.
		if length(meta.round2_indices) == 0
			meta.fully_linear = true
		end

		### Take into consideration the maximum number of evaluations allowed:
		max_new = min( max_evals(algo_config), max_evals(cfg) ) - 1 - num_evals( objf )
		n_new = min(n_missing, max_new)

		new_points = Vector{F}[]
		while !isempty(meta.improving_directions) &amp;&amp; length( new_points ) &lt; n_new
			dir = popfirst!( meta.improving_directions )
			len = intersect_bounds( x, dir, lb_1, ub_1; return_vals = :absmax )
			offset = len .* dir
			if norm( offset, Inf ) &lt;= piv_val_1
				### the new point does not pass the thresholding test
				if ensure_fully_linear &amp;&amp; !force_rebuild
					### If we need a fully linear model, we dismiss the inidices gathered so far …
					### … and call for a rebuild along the coordinate axis:
					return prepare_update_model(mod, objf, meta, mop, iter_data, db, algo_config; ensure_fully_linear = true, force_rebuild = true)
				else
					### we include the point nonetheless, but the model will not qualify as fully linear...
					meta.fully_linear = false
				end
			end
			push!( new_points, x .+ offset )
		end

		### by adding the points to the database at this point in time we avoid
		### requesting unnecessary results from a round 3 interrupted by rebuilding
		new_indices = Int[]
		for p ∈ new_points
			new_id = new_result!( db, p, F[] )
			push!(new_indices, new_id)
		end

		append!(meta.round3_indices, new_indices)
	end

	@label round4

	# In round 4 we have found `n_vars + 1` training sites and try to find additional points within the
	# largest possible trust region.
	empty!(meta.round4_indices)

	if cfg.optimized_sampling

		max_points = cfg.max_model_points &lt;= 0 ? 2 * n_vars + 1 : cfg.max_model_points
		indices_found_so_far = _collect_indices( meta )
		N = length(indices_found_so_far)

		candidate_indices_4 = results_in_box_indices( db, lb_2, ub_2, indices_found_so_far )

		max_tries = 10 * max_points
		num_tries = 0

		if N &lt; max_points &amp;&amp; ( !isempty(candidate_indices_4) || cfg.use_max_points )
			@logmsg loglevel3 &quot;Round4: Can we find $(max_points - N) additional sites?&quot;
			round4_indices = Int[]

			chol_pivot = cfg.θ_pivot_cholesky

			centers = get_site.(db, indices_found_so_far)
			φ = _get_radial_function( Δ, cfg )
			Φ, Π, kernels, polys = RBF.get_matrices( φ, centers; poly_deg = cfg.polynomial_degree )

			# prepare matrices as by Wild, R has to be augmented by rows of zeros
			Q, R = qr( transpose(Π) )
			R = [
				R;
				zeros( size(Q,1) - size(R,1), size(R,2) )
			]
			Z = Q[:, N + 1 : end ] ## columns of Z are orthogonal to Π

			# Note: usually, Z, ZΦZ and L should be empty (if N == n_vars + 1)
			ZΦZ = Hermitian(Z&#39;Φ*Z)	## make sure, it is really symmetric
			L = cholesky( ZΦZ ).L   ## perform cholesky factorization
			L⁻¹ = inv(L)				 ## most likely empty at this point

			φ₀ = Φ[1,1]

			@logmsg loglevel3 &quot;Round4: Considering $(length(candidate_indices_4)) candidates.&quot;

			while N &lt; max_points &amp;&amp; num_tries &lt;= max_tries

				if !isempty( candidate_indices_4 )
					id = popfirst!( candidate_indices_4 )
					### get candidate site ξ ∈ ℝⁿ
					ξ = get_site( db, id )
				else
					if cfg.use_max_points
						### there are no more sites in the db, but we **want**
						### to use as many as possible
						id = -1
						ξ = _rand_box_point( lb_2, ub_2, F)
						num_tries += 1
					else
						break
					end
				end

				### apply all RBF kernels
				φξ = kernels( ξ )

				### apply polynomial basis system and augment polynomial matrix
				πξ = polys( ξ )
				Rξ = [ R; πξ&#39; ]

				### perform Givens rotations to turn last row in Rξ to zeros
				row_index = size( Rξ, 1)
				G = Matrix(I, row_index, row_index) # whole orthogonal matrix
				for j = 1 : size(R,2)
					# in each column, take the diagonal as pivot to turn last elem to zero
					g = givens( Rξ[j,j], Rξ[row_index, j], j, row_index )[1]
					Rξ = g*Rξ;
					G = g*G;
				end

				### now, from G we can update the other matrices
				Gᵀ = transpose(G)
				g̃ = Gᵀ[1 : end-1, end]
				ĝ = Gᵀ[end, end]

				Qg = Q*g̃;
				v_ξ = Z&#39;*( Φ*Qg + φξ .* ĝ )
				σ_ξ = Qg&#39;*Φ*Qg + (2*ĝ) * φξ&#39;*Qg + ĝ^2*φ₀

				τ_ξ² = σ_ξ - norm( L⁻¹ * v_ξ, 2 )^2
				# τ_ξ (and hence τ_ξ^2) must be bounded away from zero
				# for the model to remain fully linear
				if τ_ξ² &gt; chol_pivot

					if id &lt; 0
						id = new_result!( db, ξ, F[] )
					end
					push!(round4_indices, id)	# accept the result

					τ_ξ = sqrt(τ_ξ²)

					# zero-pad Q and multiply with Gᵗ
					Q = [
						Q 					zeros( size(Q,1), 1);
						zeros(1, size(Q,2)) 1
					] * Gᵀ

					Z = [
						Z  						Qg;
						zeros(1, size(Z,2)) 	ĝ
					]

					L = [
						L          zeros(size(L,1), 1) ;
						v_ξ&#39;L⁻¹&#39;   τ_ξ
					]

					L⁻¹ = [
						L⁻¹                zeros(size(L⁻¹,1),1);
						-(v_ξ&#39;L⁻¹&#39;L⁻¹)./τ_ξ   1/τ_ξ
					]

					R = Rξ

					# finally, augment basis matrices and add new kernel for next iteration
					Π = [ Π πξ ]

					Φ = [
						Φ   φξ;
						φξ&#39; φ₀
					]
					push!( kernels, RBF.make_kernel(φ, ξ) )

					# assert all( diag( L * L⁻¹) .≈ 1 )
					N += 1
				end#if
			end#for
			append!(meta.round4_indices, round4_indices)
			@logmsg loglevel3 &quot;Round4: found $(length(round4_indices)) additional sites.&quot;
		end#if
	end# if cfg.optimized_sampling

	return meta
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>At the moment, we do not store the matrices calculated in round 4 of the update procedure. This could be done to save some work when actually calculating the coefficients.</p></div></div><p>In contrast to the old RBF mechanism, the models in <code>RadialBasisFunctionModels</code> sometimes accept 2 parameters for the kernel. We use this little helper, to get defaults from the shape parameter. Note, that sanity check are performed in the RbfConfig constructor.</p><pre><code class="language-julia hljs">function _get_kernel_params( Δ , cfg )

	sp = if cfg.shape_parameter isa String
		parse_shape_param_string( Δ, cfg.shape_parameter )
	else
		cfg.shape_parameter
	end

	isnan(sp) &amp;&amp; return nothing

	kernel_name = cfg.kernel

	if kernel_name == :gaussian
		return sp
	elseif kernel_name == :inv_multiquadric
		return (sp, 1//2)
	elseif kernel_name == :multiquadric
		return (sp, 1//2)
	elseif kernel_name == :cubic
		return Int(sp)
	elseif kernel_name == :thin_plate_spline
		return Int(sp)
	else
		return sp
	end
end

function _get_radial_function( Δ, cfg )
	kernel_params = _get_kernel_params( Δ, cfg )

	return RBF._get_rad_func( cfg.kernel, kernel_params )
end</code></pre><p>An improvement step consists of adding a new site to the database, along an improving direction:</p><pre><code class="language-julia hljs">function prepare_improve_model( mod :: Union{Nothing, RbfModel}, objf :: AbstractObjective,
	meta :: RbfMeta, mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB,
	algo_config :: AbstractConfig; kwargs... )
	if !meta.fully_linear
		if isempty(meta.improving_directions)
			@warn &quot;RBF model is not fully linear, but there are no improving directions.&quot;
		else
			cfg = model_cfg(objf)
			x = get_x(iter_data)
			fx = get_fx(iter_data)
			F = typeof(fx)
			Δ = get_delta(iter_data)
			Δ_1 = Δ * cfg.θ_enlarge_1
			lb_1, ub_1 = local_bounds(mop, x, Δ_1)
			piv_val_1 = Δ_1 * cfg.θ_pivot

			success = false
			dir = popfirst!( meta.improving_directions )
			len = intersect_bounds( x, dir, lb_1, ub_1; return_vals = :absmax )
			offset = len .* dir
			if norm( offset, Inf ) &gt; piv_val_1
				new_id = new_result!( db, x .+ offset, F() )
				push!(meta.round1_indices, new_id)
				success = true
			end

			success &amp;&amp; @logmsg loglevel3 &quot;Performed an improvement step.&quot;
			if isempty( meta.improving_directions ) &amp;&amp; success
				meta.fully_linear = true
				@logmsg loglevel3 &quot;The RBF Model is now fully linear.&quot;
			end
		end
	end
	return meta
end</code></pre><p>Now, in the 2-phase construction process, first all <code>prepare_</code> functions are called for all surrogate models. Then, the unevaluated results are evaluated and we can proceed with the model building. As before, <code>_init_model</code> simply delegates work to <code>update_model</code>.</p><pre><code class="language-julia hljs">function _init_model( cfg :: RbfConfig, objf :: AbstractObjective, mop :: AbstractMOP,
	iter_data :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig, meta :: RbfMeta; kwargs... )
	return update_model( nothing, objf, meta, mop, iter_data, db, ac; kwargs... )
end

function update_model( mod::Union{Nothing,RbfModel}, objf:: AbstractObjective, meta :: RbfMeta,
	mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig;
	kwargs... )

	Δ = get_delta(iter_data)
	cfg = model_cfg( objf )

	kernel_params = _get_kernel_params( Δ, cfg )

	# get the training data from `meta` and the database `db`
	training_indices = _collect_indices( meta )
	training_results = get_result.( db, training_indices )
	training_sites = get_site.( training_results )
	oi = output_indices( objf, mop)	# only consider the objective output indices
	training_values = [ v[oi] for v in get_value.( training_results ) ]

	inner_model = RBF.RBFInterpolationModel( training_sites, training_values, cfg.kernel, kernel_params; save_matrices = false )

	@logmsg loglevel3 &quot;The model is $(meta.fully_linear ? &quot;&quot; : &quot;not &quot;)fully linear.&quot;
	return RbfModel( inner_model, meta.fully_linear ), meta

end</code></pre><p>The improvement function also simply cals the update function:</p><pre><code class="language-julia hljs">function improve_model( mod::Union{Nothing,RbfModel}, objf:: AbstractObjective, meta :: RbfMeta,
	mop :: AbstractMOP, id :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig; kwargs... )
	return update_model( mod, objf, meta, mop, id, db, ac; kwargs... )
end</code></pre><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>All the work is done by the inner model :)</p><pre><code class="language-julia hljs">&quot;Evaluate `mod::RbfModel` at scaled site `x̂`.&quot;
function eval_models( mod :: RbfModel, x̂ :: Vec)
	return mod.model( x̂ )
end

&quot;Evaluate output `ℓ` of `mod::RbfModel` at scaled site `x̂`.&quot;
function eval_models( mod :: RbfModel, x̂ :: Vec, ℓ :: Int)
	return mod.model( x̂, ℓ)
end

@doc &quot;Gradient vector of output `ℓ` of `mod` at scaled site `x̂`.&quot;
function get_gradient( mod :: RbfModel, x̂ :: Vec, ℓ :: Int64)
    return RBF.grad( mod.model, x̂, ℓ )
end

@doc &quot;Jacobian Matrix of ExactModel `em` at scaled site `x̂`.&quot;
function get_jacobian( mod :: RbfModel, x̂ :: Vec )
    return RBF.jac( mod.model, x̂ )
end</code></pre><h2 id="Summary-and-Quick-Examples"><a class="docs-heading-anchor" href="#Summary-and-Quick-Examples">Summary &amp; Quick Examples</a><a id="Summary-and-Quick-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-and-Quick-Examples" title="Permalink"></a></h2><ol><li>To use the default configuration for a scalar objective <code>f</code> do<pre><code class="language-julia hljs">add_objective!(mop, f, RbfConfig())</code></pre></li><li>For a vector valued objective do<pre><code class="language-julia hljs">add_vector_objective!(mop, f, RbfConfig(); n_out = 2)</code></pre></li><li>If you don&#39;t want to use a polynomial:<pre><code class="language-julia hljs">add_objective!(mop, f, RbfConfig(;kernel = :cubic, polynomial_degree = -1 ))</code></pre>This only works for certain kernels. <code>polynomial_degree = 0</code> will add a constant term.</li><li>To require sampling of the maximum number of allowed model points:<pre><code class="language-julia hljs">RbfConfig(;use_max_points = true)</code></pre></li><li>To only sample along the coordinate axis:<pre><code class="language-julia hljs">RbfConfig(;optimized_sampling = false)</code></pre>If <code>polynomial_degree == 1</code> the model will now be a linear interpolation model.</li></ol><h3 id="Complete-usage-example"><a class="docs-heading-anchor" href="#Complete-usage-example">Complete usage example</a><a id="Complete-usage-example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-usage-example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Morbit
Morbit.print_all_logs()
mop = MixedMOP(3)

F = x -&gt; [ sum( ( x .- 1 ).^2 ); sum( ( x .+ 1 ).^2 ) ]

add_vector_objective!( mop, F, RbfConfig() )

x_fin, f_fin, _ = optimize( mop, [-π, ℯ, 0])</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-wild_diss"><a class="tag is-link" href="#citeref-wild_diss">wild_diss</a>“Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Stefan M. Wild, 2009</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ExactModel/">« ExactModels</a><a class="docs-footer-nextpage" href="../TaylorModel/">TaylorModels »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 15:48">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
