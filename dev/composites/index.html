<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Composite Functions · Morbit.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://manuelbb-upb.github.io/Morbit.jl/composites/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Morbit.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example_two_parabolas/">Two Parabolas</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li class="is-active"><a class="tocitem" href>Composite Functions</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Way:-CompositeVecFun-and-CompositeSurrogate"><span>Recommended Way: <code>CompositeVecFun</code> and <code>CompositeSurrogate</code></span></a></li><li><a class="tocitem" href="#Automatic-Function-Generation"><span>Automatic Function Generation</span></a></li></ul></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../ExactModel/">ExactModels</a></li><li><a class="tocitem" href="../RbfModel/">RbfModels</a></li><li><a class="tocitem" href="../TaylorModel/">TaylorModels</a></li><li><a class="tocitem" href="../LagrangeModel/">LagrangeModels</a></li></ul></li><li><span class="tocitem">Random Notebooks</span><ul><li><a class="tocitem" href="../notebooks/notebook_finite_differences/">Finite Differences</a></li><li><a class="tocitem" href="../notebooks/notebook_polynomial_interpolation/">Lagrange Interpolation</a></li></ul></li><li><a class="tocitem" href="../custom_logging/">Pretty Printing</a></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../dev_man/">DocStrings</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Composite Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Composite Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/Morbit.jl/blob/main/examples/composites.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Composite-Functions-and-Re-Used-Functions"><a class="docs-heading-anchor" href="#Composite-Functions-and-Re-Used-Functions">Composite Functions &amp; Re-Used Functions</a><a id="Composite-Functions-and-Re-Used-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Functions-and-Re-Used-Functions" title="Permalink"></a></h1><pre><code class="language-julia hljs">using Morbit</code></pre><p>In some situations, it might be necessary to re-use some function as part of multiple objective or constraint functions. For example, one might have an objective that also doubles as a constraint. It is then unnecessary to build multiple surrogates for this <em>inner</em> function.</p><p>Luckily, a problem of type <code>MOP</code> can be setup in such a way to only build a single surrogate model per <em>inner</em> function. More specificially, there is the possibility to add an expensive inner function <span>$g\colon ℝ^n\to ℝ^m$</span> and then re-use this inner function in objectives or constraints of the form</p><p class="math-container">\[f_ℓ (\symbf x)
=
\left( φ_ℓ ∘ (\operatorname{id}_{ℝ^n} \times g \right)(\symbf x)
=
φ_ℓ \left( \symbf x, g(\symbf x) \right), \quad
φ_ℓ \colon ℝ^n \times ℝ^m \to ℝ^{k_ℓ}.\]</p><p>We expect <span>$f_ℓ$</span> to be cheap, in the sense that the partial derivatives are either provided or can be computed using automatic differentiation or finite differencing. If derivative free models (e.g. RBF models, Lagrange models or finite differencing Taylor models) are used, then <span>$g$</span> does not have to be differentiable. Elsewise, the jacobian of <span>$f(\symbf x,\symbf y) = f_ℓ(\symbf x,\symbf y)$</span> is computed with help of the chain rule as</p><p class="math-container">\[ℝ^{k,n} ∋ Df(\symbf x_0) =
\begin{bmatrix}
D_{\symbf x} f( \symbf x_0, g(\symbf x_0) ) &amp; D_{\symbf y} f(\symbf x_0, g(\symbf x_0))
\end{bmatrix}
\cdot
\begin{bmatrix}
I_{n\times,n} \\
Dg (\symbf x_0)
\end{bmatrix}\]</p><p>The model <span>$f̃$</span> for <span>$f$</span> is <span>$φ∘g̃^{(k)}$</span>, where <span>$g̃^{(k)}$</span> is the current model for <span>$g$</span>. The jacobian is</p><p class="math-container">\[Df̃(\symbf x_0) =
\begin{bmatrix}
D_{\symbf x} f( \symbf x_0, g(\symbf x_0) ) &amp; D_{\symbf y} f(\symbf x_0, g(\symbf x_0))
\end{bmatrix}
\cdot
\begin{bmatrix}
I_{n\times,n} \\
Dg̃^{(k)} (\symbf x_0)
\end{bmatrix}\]</p><h2 id="Recommended-Way:-CompositeVecFun-and-CompositeSurrogate"><a class="docs-heading-anchor" href="#Recommended-Way:-CompositeVecFun-and-CompositeSurrogate">Recommended Way: <code>CompositeVecFun</code> and <code>CompositeSurrogate</code></a><a id="Recommended-Way:-CompositeVecFun-and-CompositeSurrogate-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Way:-CompositeVecFun-and-CompositeSurrogate" title="Permalink"></a></h2><p>We want to demonstrate how to exploit this kind of composite structure in setting up two problems, first a variation of the two parabolas problem and then a more complex example from the DTLZ family.</p><h3 id="Constraining-an-Objective"><a class="docs-heading-anchor" href="#Constraining-an-Objective">Constraining an Objective</a><a id="Constraining-an-Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Constraining-an-Objective" title="Permalink"></a></h3><p>An easy application of composing functions is to restrict an objective by value. For example, adding the constraint <span>$f_1(x) ≤ 1$</span> to the two parabola problem</p><p class="math-container">\[\min_x \begin{bmatrix}
Σ (x_i - 1)^2 \\
Σ (x_i + 1)^2
\end{bmatrix}
=
\min_x \begin{bmatrix} f_1 (\symbf x)\\ f_2(\symbf x) \end{bmatrix}\]</p><p>will effectively cut the segment <span>$[(-1,-1), (0,0)]$</span> from the unconstrained pareto set.</p><p>To use <span>$f_1$</span> both as an objective and a constraint, we set it up as an inner function and then combine it with the identity function (as the outer function) to make the objective and the constraint.</p><p>Both the inner and the outer function must be of type <code>VecFun</code>. The inner function is converted/wrapped via <code>make_inner_function</code> and then added to the model with the internal method <code>_add_function</code>:</p><pre><code class="language-julia hljs">mop = MOP(2)

f1 = Morbit.make_vec_fun(
	x -&gt; sum((x.-1).^2);
	n_out = 1, model_cfg = RbfConfig()
)
f_ind = Morbit._add_function!( mop, f1 )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.NLIndex(1, 1)</code></pre><p>Usually, we would also have to construct the outer function in a similar way (but with <code>make_outer_fun</code> – see below for the constraint). For the special case where the outer function is the identity, we can simply provide the index:</p><pre><code class="language-julia hljs">Morbit._add_objective!(mop, f_ind)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.ObjectiveIndex(1, 1)</code></pre><p>The second objective is added as usual:</p><pre><code class="language-julia hljs">add_rbf_objective!(mop, x -&gt; sum((x.+1).^2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.ObjectiveIndex(2, 1)</code></pre><p>Now, the constraint is <span>$f_1(\symbf x) - 1 \le 0$</span> and hence a suitable outer function is <span>$φ(\symbf x, f ) = f - 1$</span>. It is constructed with <code>make_outer_fun</code>, and we keep in mind that the output of the inner function has vector output (of length 1). Additionally, we have to provide <code>n_vars</code>, the length of <span>$x$</span>:</p><pre><code class="language-julia hljs">φ = Morbit.make_outer_fun(
	(x,f) -&gt; f[end] - 1;
	n_out = 1, n_vars = 2
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(::Morbit.VecFun{ExactConfig, FiniteDiffWrapper{Morbit.CountedFunc{false, Morbit.var&quot;#154#156&quot;{Int64, Main.var&quot;#5#6&quot;}}, Nothing, Nothing, Nothing}, Morbit.CountedFunc{false, Morbit.var&quot;#154#156&quot;{Int64, Main.var&quot;#5#6&quot;}}}) (generic function with 0 methods)</code></pre><p>To add it, we use <code>φ</code> as the third argument to <code>_add_XXX!</code>:</p><pre><code class="language-julia hljs">Morbit._add_nl_ineq_constraint!(mop, f_ind, φ)

x0 = [-2.0, 3.0]
x, fx, _ = optimize(mop, x0;
	max_iter = 20,
	verbosity = 0
)
x, fx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.9204539835603871, 0.9221470573551718], [0.012388649409870079, 7.382792813072106])</code></pre><h3 id="A-More-Complicated-Example"><a class="docs-heading-anchor" href="#A-More-Complicated-Example">A More Complicated Example</a><a id="A-More-Complicated-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-More-Complicated-Example" title="Permalink"></a></h3><p>The DTLZ1 problem<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> for <span>$M\in ℕ$</span> objectives is:</p><p class="math-container">\[\min_{x \in [0,1]^n}
\left[
\begin{aligned}
f_1(x) &amp;= 0.5 \cdot x_1 x_2 \dotsm x_{M-1} \left(1 + g(\symbf{x}_M)\right) \\
f_2(x) &amp;= 0.5 \cdot x_1 x_2 \dotsm x_{M-2} (1-x_{M-1}) \left(1 + g(\symbf{x}_M)\right) \\
&amp;\vdots \\
f_{M-1}(x) &amp;= 0.5 \cdot x_1 (1-x_2) \left(1 + g(\symbf{x}_M)\right) \\
f_M(x) &amp;=  0.5 \cdot (1-x_1) \left(1 + g(\symbf{x}_M)\right)
\end{aligned}
\right],
\quad
\symbf{x}_M = [x_{M}, …, x_n]^T \in ℝ^k,\]</p><p>where the expensive inner function is</p><p class="math-container">\[g(\symbf{x}_M) =
100\left(k + \sum_{x_i ∈ \symbf{x}_M} (x_i - 0.5)^2 - \cos\left( 20 π(x_i - 0.5)\right)\right)\]</p><p>The number of variables is <span>$n = M + k - 1$</span>. For any suitable values of <span>$n$</span> and <span>$M&lt;n$</span> we can set up an <code>MOP</code> programmatically. Take for example the following values:</p><pre><code class="language-julia hljs">const n = 3
const M = 2
const k = n - M + 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>For the model construction we have to reformulate our problem so that each objective has the form <span>$f_ℓ = φ_ℓ \circ (\operatorname{id}_{ℝ^n} \times g̃)$</span>, where <span>$g̃$</span> is an <span>$n$</span>-variate function. Suitable functions are</p><p class="math-container">\[\begin{aligned}
g̃(\symbf x) &amp;= g(\symbf{x}_M), \\
φ_1(\symbf x, z ) &amp;= 0.5 ⋅ ∏_{j=1}^{M-1} x_j  ⋅ (1 + z), \\
φ_ℓ(\symbf x, z ) &amp;= 0.5 ⋅ ∏_{j=1}^{M-ℓ} x_j ⋅ (1-x_{M-ℓ+1}) ⋅ (1 + z),
\quad ℓ=2,…,M
\end{aligned}\]</p><p>The inner function is easy enough to implement:</p><pre><code class="language-julia hljs">g̃ = function (x)
	global M,k
	ξ = x[M:end] .- 0.5
	return 100*(k + sum( ξ.^2 ) - sum(cos.( 20 * π .* ξ)))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#7 (generic function with 1 method)</code></pre><p>We initialize the box constrained problem and use the internal method <code>_add_function</code> to add the inner function. It requires a <code>VecFun</code> and returns an <code>NLIndex</code> that we need for referencing.</p><pre><code class="language-julia hljs">mop = MOP( zeros(n), ones(n) )

g̃_vfun = Morbit.make_vec_fun( g̃; model_cfg = RbfConfig(), n_out = 1)
g_ind = Morbit._add_function!( mop, g̃_vfun )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.NLIndex(1, 1)</code></pre><p>We then have to turn the outer functions to <code>VecFun</code>s (so that they can be differentiated). When that is done, they can be passed to <code>_add_objective!</code> together with the index of the inner function. As in the first example, <code>n_vars</code> is the dimension of <span>$\symbf x$</span> and <code>n_out=1</code> indicates scaler valued outer functions:</p><pre><code class="language-julia hljs">φ1 = Morbit.make_outer_fun(
	(x,z) -&gt; 0.5 * prod( x[1:M-1] ) * (1 + z[end] );
	n_vars = n, n_out = 1,
	diff_method = Morbit.AutoDiffWrapper
)
Morbit._add_objective!(mop, g_ind, φ1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.ObjectiveIndex(1, 1)</code></pre><p>In the same way we add the remaining objectives:</p><pre><code class="language-julia hljs">for ℓ = 2 : M
	φℓ = Morbit.make_outer_fun(
		(x,z) -&gt; 0.5 * prod( x[1:M-ℓ] ) * (1 - x[M-ℓ+1]) * (1 + z[end] );
		n_vars = n, n_out = 1,
		diff_method = Morbit.AutoDiffWrapper
	)
	Morbit._add_objective!(mop, g_ind, φℓ)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Using AutoDiffWrapper for gradients.
└ @ Morbit ~/work/Morbit.jl/Morbit.jl/src/VecFun.jl:129</code></pre><p>We can now pass <code>mop</code> to <code>optimize</code> as always:</p><pre><code class="language-julia hljs">x0 = rand(n)
x, fx, _ = optimize(mop, x0; verbosity = 0, max_iter = 100)
x, fx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.40091869113787776, 0.39985341697642957, 0.6998284598499168], [1.2039838478359055, 1.7990785547145658])</code></pre><p>Now, the inner function <span>$g$</span> is Rastrigin&#39;s function and has <span>$11^k-1$</span> local optima, so we cannot expect that <code>x</code> belongs to the global Pareto Set with <span>$\symbf x_M = 0.5$</span>. Rather, the problem was selected to demonstrate the modelling.</p><h2 id="Automatic-Function-Generation"><a class="docs-heading-anchor" href="#Automatic-Function-Generation">Automatic Function Generation</a><a id="Automatic-Function-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Function-Generation" title="Permalink"></a></h2><p>The second way to add composite objectives is provided by automatic generation of outer functions from special expression strings. I guess it is slower.</p><p>Suppose you have a problem <code>mop::MOP</code> and an inner function with index <code>g_ind</code>. You can then call <code>_add_objective!(mop, g_ind, expr_str)</code> (or <code>add_nl_eq_constraint!(…)</code> or <code>add_nl_ineq_constraint!(…)</code>) to add a composite function to the model. <code>expr_str</code> must be a string with describing a function of a variable <code>x</code>. Each occurence of the word &quot;VREF&quot; is substituted with an evaluation of the inner function at <code>x</code>.</p><pre><code class="language-julia hljs">mop = MOP(2)

g = Morbit.make_vec_fun( x -&gt; sum(x.^2); model_cfg = RbfConfig(), n_out = 1)
g_ind = Morbit._add_function!(mop, g)

objf_ind1 = Morbit._add_objective!(mop, g_ind, &quot;sin( VREF[1] ) * sum(x)&quot;;
	n_vars = 2, n_out = 1
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Morbit.ObjectiveIndex(1, 1)</code></pre><p>If you cant to use a custom function in the expression string, it has to be registered first:</p><pre><code class="language-julia hljs">Morbit.register_func(x -&gt; cos(x), :my_func)

objf_ind2 = Morbit._add_objective!(mop, g_ind, &quot;my_func( VREF[1] ) * sum(x)&quot;;
	n_vars = 2, n_out = 1
)

x, fx, _ = optimize(mop, rand(2); verbosity = 0)
x, fx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-0.7277642792236425, -0.7398653676802898], [-1.2923353389693286, -0.6955617529180221])</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>“Scalable Test Problems for Evolutionary Multi-Objective Optimization”, Deb, Thiele, Laumanns &amp; Zitzlera</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constraints/">« Constraints</a><a class="docs-footer-nextpage" href="../ExactModel/">ExactModels »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 10 May 2022 13:04">Tuesday 10 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
