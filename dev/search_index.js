var documenterSearchIndex = {"docs":
[{"location":"notebook_finite_differences/","page":"Finite Differences","title":"Finite Differences","text":"<iframe id=\"fdnotebook\" src=\"../custom_assets/notebook_finite_differences.html\" width=\"100%\"></iframe>\n<!--<script src=\"../custom_assets/iframeResizer.min.js\"></srcipt>-->\n<script>\nconst iFrameResizerPath = '../custom_assets/iframeResizer.min.js';\n\nif (require) {\n  require([iFrameResizerPath], (iFrameResize) => iFrameResize())\n} else {\n  const script = document.createElement('script')\n  script.onload = () => iFrameResize()\n  script.src = iFrameResizerPath\n}\n</script>\n<script>\ndocument.addEventListener('DOMContentLoaded', function(){\n\tvar myIframe = document.getElementById(\"fdnotebook\");\n\tiFrameResize({log:true}, myIframe);\t\n});\n</script>","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"EditURL = \"https://github.com/manuelbb-upb/Morbit.jl/blob/master/examples/example_two_parabolas.jl\"","category":"page"},{"location":"example_two_parabolas/#Two-Parabolas","page":"Two Parabolas","title":"Two Parabolas","text":"","category":"section"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"The ‚Äútwo parabolas‚Äù problem in two dimensions reads as","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"    min_ùê±  X \n    beginbmatrix f‚ÇÅ(mathbfx)  f‚ÇÇ(mathbfx) endbmatrix =\n    min_mathbfx  X\n    beginbmatrix\n    (x‚ÇÅ - 1)¬≤ + (x‚ÇÇ - 1)¬≤ \n    (x‚ÇÅ + 1)¬≤ + (x‚ÇÇ + 1)¬≤\n    endbmatrix","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"It is unconstrained if the feasible set is X = ‚Ñù^2. The individual minima 11 and -1-1 are such that (in the unconstrained case) the global Pareto Set is","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"mathcalP_S =  mathbfx  ‚Ñù^2  x‚ÇÅ = x‚ÇÇ  -1 le x‚ÇÅ x‚ÇÇ le 1  ","category":"page"},{"location":"example_two_parabolas/#Solve-using-Exact-Functions","page":"Two Parabolas","title":"Solve using Exact Functions","text":"","category":"section"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"The gradients are easily calculated as","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"nabla f_1 (mathbf x) = 2 beginbmatrix\nx_1 -1  x_2 - 1 endbmatrix \nnabla f_2 (mathbf x) = 2 beginbmatrix\nx_1 +1  x_2 + 1 endbmatrix ","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"We can provide them to the solver to find a critical point:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"import Logging #src\n\n\nusing Morbit\n\nf‚ÇÅ = x -> sum( (x .- 1).^2 )\nf‚ÇÇ = x -> sum( (x .+ 1).^2 )\n‚àáf‚ÇÅ = x -> 2 .* ( x .- 1 )\n‚àáf‚ÇÇ = x -> 2 .* ( x .+ 1 )\n\nmop = MixedMOP(2);  # problem with 2 variables\nadd_objective!(mop, f‚ÇÅ, ‚àáf‚ÇÅ )\nadd_objective!(mop, f‚ÇÇ, ‚àáf‚ÇÇ )\n\n#  starting point\nx‚ÇÄ = [ -œÄ ;  2.71828 ]\n\n#  set maximum number of iterations\nac = AlgoConfig( max_iter = 20)\n#  `optimize` will return parameter and result vectors as well\n#  as an `Morbit.IterData` object.\nx, fx, id = optimize( mop, x‚ÇÄ; algo_config = ac );\nx","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"Hopefully, x is critical, i.e., x[1] ‚âà x[2].","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"note: Note\nTo print more information on what the solver is doing, you can use the Logging module:import Logging: global_logger, ConsoleLogger\nglobal_logger( ConsoleLogger( stderr, Morbit.loglevel4;\n    meta_formatter = Morbit.morbit_formatter ) )loglevel4 is the most detailed and loglevel1 is least detailed.","category":"page"},{"location":"example_two_parabolas/#Plotting-Iteration-Sites","page":"Two Parabolas","title":"Plotting Iteration Sites","text":"","category":"section"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"We can retrieve iteration data from id and the database Morbit.db(id)","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"db = Morbit.db(id);\nnothing #hide","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"Let's retrieve the iteration sites. We convert to Tuples for easier plotting.","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"it_sites = Tuple.(Morbit.get_iterate_sites(db));\nnothing #hide","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"For Plotting we use CairoMakie","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"using CairoMakie\n\n#  Pareto Set ‚âô line from (-1,-1) to (1,1)\nfig, ax, _ = lines( [(-1,-1),(1,1)]; color = :blue, linewidth = 2,\n    figure = (resolution = (600, 600),) )\n\n#  Plot the iteration sites:\nlines!(it_sites)\nscatter!(it_sites;\n    color = LinRange(0, 1, length(it_sites)),\n    colormap = :winter\n)\n\n#  Plot function contours\nY = X = LinRange(-4, 4, 100)\nZ‚ÇÅ = [ f‚ÇÅ([x;y]) for x ‚àà X, y ‚àà X ]\nZ‚ÇÇ = [ f‚ÇÇ([x;y]) for x ‚àà X, y ‚àà X ]\nlevels = [ i.^2 for i = LinRange(.1, 6, 6) ]\ncontour!(X,Y,Z‚ÇÅ; colormap = :greens, levels = levels, linewidth = .5 )\ncontour!(X,Y,Z‚ÇÇ; colormap = :heat, levels = levels, linewidth = .5 )\n\n#  Show the plot:\nax.title[] = \"Pareto Set and Iterates.\"\nax.xgridvisible[] = false\nax.ygridvisible[] = false\n\nfig","category":"page"},{"location":"example_two_parabolas/#Solving-using-RBF-Surrogates","page":"Two Parabolas","title":"Solving using RBF Surrogates","text":"","category":"section"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"Suppose now that we do not have access to the objective gradients and that the objectives also take some time to evaluate. In this situation, we could try to model them using surrogate models. To use radial basis function models, pass an RbfConfig when specifying the objective:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"mop_rbf = MixedMOP()\n\n#  Define the RBF surrogates\nrbf_cfg = RbfConfig(\n    kernel = :multiquadric,\n    shape_parameter = \"20/Œî\"\n)\n#  Add objective functions to `mop_rbf`\nadd_objective!(mop_rbf, f‚ÇÅ, rbf_cfg )\nadd_objective!(mop_rbf, f‚ÇÇ, rbf_cfg )\n\n#  only perform 10 iterations\nac = AlgoConfig( max_iter = 10 )\nx, fx, id = optimize( mop, x‚ÇÄ; algo_config = ac )\nx\n\nit_sites_rbf = Tuple.(Morbit.get_iterate_sites(Morbit.db(id))) #hide\nlines!(it_sites); #hide\nscatter!(it_sites; color = :orange); #hide\nnothing #hide","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"The iteration sites are the orange circles:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"fig #hide","category":"page"},{"location":"example_two_parabolas/#Different-Starting-Points-and-Recycling-Data","page":"Two Parabolas","title":"Different Starting Points and Recycling Data","text":"","category":"section"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"The method could converge to different points depending on the starting point. We can pass the evaluation data from previous runs to facilitate the construction of surrogate models:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"ac = AlgoConfig( max_iter = 10 ); #hide\nmop_rbf = MixedMOP(); #hide\n#  define the RBF surogates #hide\nrbf_cfg = RbfConfig(  #hide\n    kernel = :multiquadric, #hide\n    shape_parameter = \"20/Œî\"  #hide\n); #hide\n#  add objective functions to `mop_rbf` #hide\nadd_objective!(mop_rbf, f‚ÇÅ, rbf_cfg ); #hide\nadd_objective!(mop_rbf, f‚ÇÇ, rbf_cfg ); #hide\n#  an array of well spread points in [-4,4]¬≤ #hide\nX =[ #hide\n [-4.0, -4.0], #hide\n [3.727327839472812, 3.8615291196035457], #hide\n [3.804712690019901, -3.9610212058521235], #hide\n [-0.14512898384374573, -0.005775390168885508], #hide\n [-3.775315499879552, 3.8150054323309064], #hide\n [1.714228746087743, 1.8435786475209621], #hide\n [-1.9603720505875337, -2.0123206708499275], #hide\n [3.9953803225349187, -0.47734576293976794], #hide\n [-3.9944468955728745, 0.49857343385493635], #hide\n [-1.0455585089057458, 2.735699160002545] #hide\n]; #hide\n\n#  Suppose, `X` is a list of different points in ‚Ñù¬≤.\n\n#  A dict to associate starting and end points:\nstart_fin_points = Dict();\n\n#  perform several runs:\ndb‚ÇÄ = nothing # initial database can be `nothing`\nfor x‚ÇÄ ‚àà X\n    global db‚ÇÄ\n    x_fin, fx_fin, idat = optimize( mop_rbf, x‚ÇÄ; algo_config = ac, populated_db = db‚ÇÄ )\n    #  add points to dict\n    start_fin_points[x‚ÇÄ] = x_fin\n    #  merge databases for recycling\n    db‚ÇÄ = Morbit.merge( db‚ÇÄ, Morbit.db(idat) )\nend","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"Plotting:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"fig, ax, _ = lines( [(-1,-1),(1,1)]; color = :blue, linewidth = 2,\n    figure = (resolution = (600, 600), ),\n    axis = (title=\"Different Starting Points\",),\n)\n\nfor (k,v) in start_fin_points\n    lines!( [ Tuple(k), Tuple(v) ]; color = :lightgray )\nend\n\nscatter!( Tuple.(keys(start_fin_points));\n    color = :green\n)\nscatter!( Tuple.(values(start_fin_points));\n    color = :lightblue\n)\n\nfig #hide","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"In the plot, the green points show the starting points and the lightblue circles show the final iterates:","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"","category":"page"},{"location":"example_two_parabolas/","page":"Two Parabolas","title":"Two Parabolas","text":"This page was generated using Literate.jl.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"EditURL = \"https://github.com/manuelbb-upb/Morbit.jl/blob/master/src/RbfModel.jl\"","category":"page"},{"location":"RbfModel/#Radial-Basis-Function-Surrogate-Models","page":"RbfModels","title":"Radial Basis Function Surrogate Models","text":"","category":"section"},{"location":"RbfModel/#Intro-and-Prerequisites","page":"RbfModels","title":"Intro and Prerequisites","text":"","category":"section"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"We want to offer radial basis function (RBF) surrogate models (implementing the SurrogateModel interface). To this end, we leverage the package RadialBasisFunctionModels.jl. A scalar RBF model consists of a n-variate Polynomial and linear combination of shifted radial kernels. For more information, see the documentation of RadialBasisFunctionModels.jl.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"import RadialBasisFunctionModels as RBF\nusing LinearAlgebra: qr, Hermitian, cholesky, inv, I, givens, diag","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The polyonmials will have a degree of at most 1. To construct ‚Äúgood‚Äù linear polynomials, we need to make sure to have construction sites, that span the decision space well. Such a set of construction sites is called Œõ-poised or sufficiently affinely independent. The file AffinelyIndependentPoints implements some helpers to find suitable points as described by Wild et. al.[wild_diss]","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"include(\"AffinelyIndependentPoints.jl\")","category":"page"},{"location":"RbfModel/#Surrogate-Interface-Implementations","page":"RbfModels","title":"Surrogate Interface Implementations","text":"","category":"section"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The model used in our algorithm simply wraps an interpolation model from the RBF package.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"@with_kw struct RbfModel{R} <: SurrogateModel\n\tmodel :: R\n\n\t# indicator: is the model fully linear?\n\tfully_linear :: Bool = false\nend\n\nfully_linear( rbf :: RbfModel ) :: Bool = rbf.fully_linear","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"We offer a large range of configuration parameters in the RBFConfig, which implements a SurrogateConfig.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"\"\"\"\n    RbfConfig(; kwarg1 = val1, ‚Ä¶ )\n\nConfiguration type for local RBF surrogate models.\n\nTo choose a kernel, use the kwarg `kernel` and a value of either\n`:cubic` (default), `:inv_multiquadric`, `:multiquadric`, `:gaussian` or `:thin_plate_spline`.\nThe kwarg `shape_parameter` takes a constant number or a string\nthat defines a calculation on `Œî`, e.g, \"Œî/10\".\nNote, that `shape_parameter` has a different meaning for the different kernels.\nFor ``:gaussian, :inv_multiquadric, :multiquadric` it actually is a floating point shape_parameter.\nFor :cubic it is the (odd) integer exponent and for `thin_plate_spline` it is an integer exponent as well.\nUse `NaN` for defaults.\n\nTo see other configuration parameters use `fieldnames(Morbit.RbfConfig)`.\nThey have individual docstrings attached.\n\"\"\"\n@with_kw mutable struct RbfConfig <: SurrogateConfig\n    \"(default `:cubic`) RBF kernel (Symbol), either `:cubic`, `:multiquadric`, `:exp` or `:thin_plate_spline`.\"\n    kernel :: Symbol = :cubic\n\n\t\"(default `1`) RBF shape paremeter, either a number or a string containing `Œî`.\"\n    shape_parameter :: Union{String, Float64} = NaN\n\n\t\"(default `1`) Degree of polynomial attached to RBF. `-1` means no polynomial.\"\n    polynomial_degree :: Int64 = 1;\n\n    \"(default `2`) Local enlargment factor of trust region for sampling.\"\n    Œ∏_enlarge_1 :: Float64 = 2\n\n\t\"(default `5`) Maximum enlargment factor of maximum trust region for sampling.\"\n    Œ∏_enlarge_2 :: Float64 = 2\n\n\t\"(default `1/(2*Œ∏_enlarge_1)` Sampling parameter to generate Œõ-poised set. The higher, the more poised.\"\n    Œ∏_pivot :: Float64 = 1 / (2 * Œ∏_enlarge_1)\n\n\t\"(default `1e-7`) Parameter for 2nd sampling algorithm to ensure boundedness of Cholesky factors.\"\n    Œ∏_pivot_cholesky :: Float64 = 1e-7\n\n    \"(default `false`) Require models to be fully linear in each iteration.\"\n    require_linear :: Bool = false\n\n    \"(default `-1`) Maximum number of training sites. `-1` is reset to `2n+1`.\"\n    max_model_points :: Int64 = -1 # is probably reset in the algorithm\n    \"(default `false`) Sample new sites to always use the maximum number of points.\"\n    use_max_points :: Bool = false\n\n#    \"(default `:orthogonal`) Algorithm to use for finding affinely independent set.\"\n#    sampling_algorithm :: Symbol = :orthogonal # :orthogonal or :monte_carlo\n\n##\t\"(default `:standard_rand`) Algorithm to use if additional points are required.\"\n#    sampling_algorithm2 :: Symbol = :standard_rand\n\n    \"(default `typemax(Int64)`) Maximum number of objective evaluations.\"\n    max_evals :: Int64 = typemax(Int64)\n\n\t@assert Œ∏_enlarge_1 * Œ∏_pivot ‚â§ 1 \"Œ∏_pivot must be <= Œ∏_enlarge_1^(-1).\"\n\n##\t@assert sampling_algorithm ‚àà [:orthogonal, :monte_carlo] \"Sampling algorithm must be either `:orthogonal` or `:monte_carlo`.\"\n    @assert kernel ‚àà Symbol.([\"gaussian\", \"inv_multiquadric\", \"multiquadric\", \"cubic\", \"thin_plate_spline\"]) \"Kernel '$kernel' not supported yet.\"\n\t# Some sanity checks for the shape parameters\n    @assert kernel != :thin_plate_spline || ( isnan(shape_parameter) || shape_parameter % 1 == 0 && shape_parameter >= 1 ) \"Invalid shape_parameter for :thin_plate_spline.\"\n\t@assert kernel != :cubic || ( isnan(shape_parameter) || shape_parameter % 1 == 0 && shape_parameter % 2 == 1 ) \"Invalid shape_parameter for :cubic.\"\n\t@assert isnan(shape_parameter) || shape_parameter > 0 \"Shape parameter must be strictly positive.\"\n    # @assert Œ∏_enlarge_1 >=1 && Œ∏_enlarge_2 >=1 \"Œ∏'s must be >= 1.\"\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The required method implementations are straightforward. Note, thate we allow the models to be combined to vector functions if they share the same configuration to avoid redundant efforts whilst constructing models.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"max_evals( cfg :: RbfConfig ) :: Int = cfg.max_evals\ncombinable( cfg :: RbfConfig ) :: Bool = true\ncombine(cfg1 :: RbfConfig, :: RbfConfig) :: RbfConfig = cfg1","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"We also need to introduce our own implementation for isequal and hash for RbfConfigs to be combinable, see the docs too.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function Base.hash( cfg :: RbfConfig, h :: UInt )\n\treturn hash( getfield.( cfg, Tuple( fn for fn ‚àà fieldnames(RbfConfig) ) ), h )\nend\nfunction Base.isequal( cfg1 :: RbfConfig, cfg2 :: RbfConfig )\n\tall( isequal( getfield(cfg1, fn), getfield(cfg2, fn) ) for fn in fieldnames( RbfConfig) )\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"To allow the user to set the shape parameter relative to the current trust region radius using a verbose string, we need this little helper function, which evaluates the string.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function parse_shape_param_string( Œî :: F, expr_str) :: F where F\n    ex = Meta.parse(expr_str)\n    return @eval begin\n        let Œî=$Œî\n            $ex\n        end\n    end\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The RbfMeta is used to store construction and update data for the models. To be specific, we have several inidices lists that store database indices of (potentially unevaluated) results that are later used for fitting the model.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"@with_kw mutable struct RbfMeta{F<:AbstractFloat} <: SurrogateMeta\n    center_index :: Int = -1\n    round1_indices :: Vector{Int} = []\n    round2_indices :: Vector{Int} = []\n    round3_indices :: Vector{Int} = []\n    round4_indices :: Vector{Int} = []\n    fully_linear :: Bool = false\n\timproving_directions :: Vector{Vector{F}} = []\nend\n\n\nsaveable_type( meta :: T ) where {T<:RbfMeta} = T\nsaveable( meta :: RbfMeta ) = deepcopy(meta)","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"A little helper to retrieve all those indices:","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function _collect_indices( meta :: RbfMeta; include_x = true ) :: Vector{Int}\n\treturn [\n\t\tinclude_x ? meta.center_index : [];\n\t\tmeta.round1_indices;\n\t\tmeta.round2_indices;\n\t\tmeta.round3_indices;\n\t\tmeta.round4_indices\n\t]\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"And a helper, to partially copy some data from src to dest. This is due to the fact, that the first 3 rounds of construction data gathering are the same for all possible RBF models and we can safe some effort.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function copy_meta!(dest, src)\n\tdest.center_index = src.center_index\n\tfor fn in [ Symbol(\"round$(i)_indices\") for i = 1: 3 ]\n\t\tdest_arr = getfield(dest, fn)\n\t\tempty!( dest_arr )\n\t\tappend!( dest_arr, getfield( src, fn) )\n\tend\n\tempty!(dest.improving_directions)\n\tappend!(dest.improving_directions, src.improving_directions)\nend\n\nexport RbfConfig, RbfMeta, RbfModel","category":"page"},{"location":"RbfModel/#Construction","page":"RbfModels","title":"Construction","text":"","category":"section"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The initial prepare_init_model function should return a meta object that can be used to build an initial surrogate model. We delegate the work to prepare_update_model.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function prepare_init_model( cfg :: RbfConfig, objf :: AbstractObjective, mop :: AbstractMOP,\n\tid :: AbstractIterData{F}, db :: AbstractDB, ac :: AbstractConfig;\n\tensure_fully_linear = true, kwargs...) where F<:AbstractFloat\n\n\tmeta = RbfMeta{F}()\n\treturn prepare_update_model(nothing, objf, meta, mop, id, db, ac; ensure_fully_linear = true, kwargs... )\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"Usually, prepare_update_model would only accept a model as its first argument. Because of the trick from above, we actually allow nothing, too.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function prepare_update_model( mod :: Union{Nothing, RbfModel}, objf :: AbstractObjective, meta :: RbfMeta,\n\tmop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, algo_config :: AbstractConfig;\n\tensure_fully_linear = false, force_rebuild = false, meta_array = nothing )\n\n\t!force_rebuild && @logmsg loglevel2 \"Trying to find results for fitting an RBF model.\"\n\n\t# Retrieve current iteration information and some meta data.\n\tŒî = get_Œî(iter_data)\n\tŒî_max = Œî·µò(algo_config)\n\tx = get_x(iter_data)\n\tx_index = get_x_index(iter_data)\n\tcfg = model_cfg( objf )\n\n\tF = eltype(x)\n\tn_vars = length(x)\n\n\t# Can we skip the first rounds? (Because we already found interpolation sets for other RBFModels?)\n\tall_objfs = list_of_objectives(mop)\n\tskip_first_rounds = false\n\tfor (i,other_meta) in enumerate(meta_array)\n\t\tother_objf = all_objfs[i]\n\t\tif other_meta isa RbfMeta\n\t\t\tother_cfg = model_cfg(other_objf)\n\t\t\tif other_cfg.Œ∏_pivot == cfg.Œ∏_pivot && other_cfg.Œ∏_enlarge_1 == cfg.Œ∏_enlarge_1 && other_cfg.Œ∏_enlarge_2 == cfg.Œ∏_enlarge_2\n\t\t\t\tcopy_meta!( meta, other_meta )\n\t\t\t\tskip_first_rounds = true\n\t\t\tend\n\t\tend\n\tend\n\n\t# By default, assume that our model is not fully linear\n\tmeta.fully_linear = false\n\n\t# use center as first training site ‚áí at least `n_vars` required still\n\tmeta.center_index = x_index\n\n\t# First round of sampling:\n\t### Try to find points in slightly enlarged trust region\n\tŒî_1 = F.(cfg.Œ∏_enlarge_1 * Œî)\n\tlb_1, ub_1 = local_bounds( mop, x, Œî_1 )\n\tpiv_val_1 = F.(cfg.Œ∏_pivot * Œî_1) # threshold value for acceptance in filter\n\n\t### `Œî_2` is the maximum allowed trust region radius and used in rounds 2 & 4\n\tŒî_2 = F.(cfg.Œ∏_enlarge_2 * Œî_max )\n\tlb_2, ub_2 = local_bounds( mop, x, Œî_2 )\n\tpiv_val_2 = piv_val_1 # the pivot value stays the same\n\n\tskip_first_rounds && @goto round4\n\n\tif force_rebuild\n\t\t### `force_rebuild` makes us skip the point searching procedures to ‚Ä¶\n\t\t### ‚Ä¶ rebuild the model along the coordinate axes.\n\t\tfiltered_indices_1 = Int[]\n\t\timproving_directions = [ [zeros(F,i-1); one(F); zeros(F,n_vars - i)] for i = 1:n_vars ]\n\telse\n\t\t@logmsg loglevel3 \"Round1: Inspect box with radius $(Œî_1) and pivot value $(piv_val_1).\"\n\n\t\t### only consider points from within current trust region ‚Ä¶\n\t\tcandidate_indices_1 = results_in_box_indices( db, lb_1, ub_1, [x_index],)\n\n\t\t### ‚Ä¶ and filter them to obtain affinely independent points.\n\t\tfilter = AffinelyIndependentPointFilter(;\n\t\t\tx_0 = x,\n\t\t\tseeds = get_site.(db, candidate_indices_1),\n\t\t\treturn_indices = true,\n\t\t\tpivot_val = piv_val_1\n\t\t)\n\n\t\tfiltered_indices_1 = candidate_indices_1[ collect( filter ) ]\n\t\timproving_directions = reverse(collect(Vector{F}, eachcol(filter.Z)))\n\n\t\t@logmsg loglevel3 \"Round1: Found $(length(filtered_indices_1)) sites in database.\"\n\tend\n\t### Store indices in meta data object:\n\tempty!(meta.round1_indices)\n\tappend!(meta.round1_indices, filtered_indices_1)\n\tempty!(meta.improving_directions)\n\tappend!(meta.improving_directions, improving_directions )\n\n\t# Second round of sampling:\n\t### If there are not enough sites to have a fully linear model ‚Ä¶\n\t### ‚Ä¶ try to at least find more sites in maximum allowed radius\n\tn_missing = n_vars - length( filtered_indices_1 )\n\n\tif n_missing == 0 || force_rebuild || ensure_fully_linear || Œî ‚âà Œî_max && cfg.Œ∏_enlarge_1 == cfg.Œ∏_enlarge_2\n\t\t@logmsg loglevel3 \"Skipping round 2.\"\n\n\t\tmeta.fully_linear = true\n\t\tfilter_2 = filter\n\t\tempty!(meta.round2_indices)\n\telse\n\t\t### actually perform round 2\n\n\t\t@logmsg loglevel3 \"Missing $(n_missing) sites still.\"\n\t\t@logmsg loglevel3 \"Round2: Inspect box with radius $(Œî_2) and pivot value $(piv_val_1).\"\n\n\t\t### as before, only consider points in box of radius `Œî_2`, but ignore `x` and the previous points\n\t\tcandidate_indices_2 = results_in_box_indices( db, lb_2, ub_2, [x_index; candidate_indices_1])\n\n\t\tfilter_2 = AffinelyIndependentPointFilter(;\n\t\t\tx_0 = x,\n\t\t\tseeds = get_site.(db, candidate_indices_2),\n\t\t\tY = filter.Y,\t# pass prior matrices, so that new points are projected onto span of Z\n\t\t\tZ = filter.Z,\n\t\t\tn = n_missing,\n\t\t\treturn_indices = true,\n\t\t\tpivot_val = piv_val_2\n\t\t)\n\n\t\tfiltered_indices_2 = candidate_indices_2[ collect(filter_2) ]\n\n\t\t### Store indices\n\t\tempty!(meta.round2_indices)\n\t\tappend!(meta.round2_indices, filtered_indices_2)\n\n\t\t@logmsg loglevel3 \"Round2: Found $(length(meta.round2_indices)) sites and model is $(meta.fully_linear ? \"\" : \"not \" )fully linear.\"\n\tend\n\n\t# Round 3:\n\t### If we still don't have enough sites, generate them\n\t### along model improving directions (from first round of sampling)\n\n\tn_missing -= length(meta.round2_indices)\n\tempty!(meta.round3_indices)\n\tif n_missing > 0\n\n\t\t@logmsg loglevel3 \"Round3: Still missing $(n_missing). Sampling in box of radius $(Œî_1).\"\n\n\t\t### If round 2 did not yield any new points, the model will hopefully be made fully linear now.\n\t\tif length(meta.round2_indices) == 0\n\t\t\tmeta.fully_linear = true\n\t\tend\n\n\t\t### Take into consideration the maximum number of evaluations allowed:\n\t\tmax_new = min( max_evals(algo_config), max_evals(cfg) ) - 1 - num_evals( objf )\n\t\tn_new = min(n_missing, max_new)\n\n\t\tnew_points = Vector{F}[]\n\t\twhile !isempty(meta.improving_directions) && length( new_points ) < n_new\n\t\t\tdir = popfirst!( meta.improving_directions )\n\t\t\tlen = intersect_bounds( x, dir, lb_1, ub_1; return_vals = :absmax )\n\t\t\toffset = len .* dir\n\t\t\tif norm( offset, Inf ) <= piv_val_1\n\t\t\t\t### the new point does not pass the thresholding test\n\t\t\t\tif ensure_fully_linear && !force_rebuild\n\t\t\t\t\t### If we need a fully linear model, we dismiss the inidices gathered so far ‚Ä¶\n\t\t\t\t\t### ‚Ä¶ and call for a rebuild along the coordinate axis:\n\t\t\t\t\treturn prepare_update_model(mod, objf, meta, mop, iter_data, db, algo_config; ensure_fully_linear = true, force_rebuild = true)\n\t\t\t\telse\n\t\t\t\t\t### we include the point nonetheless, but the model will not qualify as fully linear...\n\t\t\t\t\tmeta.fully_linear = false\n\t\t\t\tend\n\t\t\tend\n\t\t\tpush!( new_points, x .+ offset )\n\t\tend\n\n\t\t### by adding the points to the database at this point in time we avoid\n\t\t### requesting unnecessary results from a round 3 interrupted by rebuilding\n\t\tnew_indices = Int[]\n\t\tfor p ‚àà new_points\n\t\t\tnew_id = new_result!( db, p, F[] )\n\t\t\tpush!(new_indices, new_id)\n\t\tend\n\n\t\tappend!(meta.round3_indices, new_indices)\n\tend\n\n\t@label round4\n\n\t# In round 4 we have found `n_vars + 1` training sites and try to find additional points within the\n\t# largest possible trust region.\n\tempty!(meta.round4_indices)\n\n\tmax_points = cfg.max_model_points <= 0 ? 2 * n_vars + 1 : cfg.max_model_points\n\tindices_found_so_far = _collect_indices( meta )\n\tN = length(indices_found_so_far)\n\n\tcandidate_indices_4 = results_in_box_indices( db, lb_2, ub_2, indices_found_so_far )\n\n\tmax_tries = 10 * max_points\n\tnum_tries = 0\n\n\tif N < max_points && ( !isempty(candidate_indices_4) || cfg.use_max_points )\n\t\t@logmsg loglevel3 \"Round4: Can we find $(max_points - N) additional sites?\"\n\t\tround4_indices = Int[]\n\n\t\tchol_pivot = cfg.Œ∏_pivot_cholesky\n\n\t\tcenters = get_site.(db, indices_found_so_far)\n\t\tœÜ = _get_radial_function( Œî, cfg )\n\t\tŒ¶, Œ†, kernels, polys = RBF.get_matrices( œÜ, centers; poly_deg = cfg.polynomial_degree )\n\n\t\t# prepare matrices as by Wild, R has to be augmented by rows of zeros\n\t\tQ, R = qr( transpose(Œ†) )\n        R = [\n            R;\n            zeros( size(Q,1) - size(R,1), size(R,2) )\n        ]\n        Z = Q[:, N + 1 : end ] ## columns of Z are orthogonal to Œ†\n\n\t\t# Note: usually, Z, ZŒ¶Z and L should be empty (if N == n_vars + 1)\n        ZŒ¶Z = Hermitian(Z'Œ¶*Z)\t## make sure, it is really symmetric\n        L = cholesky( ZŒ¶Z ).L   ## perform cholesky factorization\n        L‚Åª¬π = inv(L)\t\t\t\t ## most likely empty at this point\n\n        œÜ‚ÇÄ = Œ¶[1,1]\n\n\t\t@logmsg loglevel3 \"Round4: Considering $(length(candidate_indices_4)) candidates.\"\n\n\t\twhile N < max_points && num_tries <= max_tries\n\n\t\t\tif !isempty( candidate_indices_4 )\n\t\t\t\tid = popfirst!( candidate_indices_4 )\n\t\t\t\t### get candidate site Œæ ‚àà ‚Ñù‚Åø\n\t\t\t\tŒæ = get_site( db, id )\n\t\t\telse\n\t\t\t\tif cfg.use_max_points\n\t\t\t\t\t### there are no more sites in the db, but we **want**\n\t\t\t\t\t### to use as many as possible\n\t\t\t\t\tid = -1\n\t\t\t\t\tŒæ = _rand_box_point( lb_2, ub_2, F)\n\t\t\t\t\tnum_tries += 1\n\t\t\t\telse\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t### apply all RBF kernels\n\t\t\tœÜŒæ = kernels( Œæ )\n\n\t\t\t### apply polynomial basis system and augment polynomial matrix\n\t\t\tœÄŒæ = polys( Œæ )\n\t\t\tRŒæ = [ R; œÄŒæ' ]\n\n\t\t\t### perform Givens rotations to turn last row in RŒæ to zeros\n\t\t\trow_index = size( RŒæ, 1)\n\t\t\tG = Matrix(I, row_index, row_index) # whole orthogonal matrix\n\t\t\tfor j = 1 : size(R,2)\n\t\t\t\t# in each column, take the diagonal as pivot to turn last elem to zero\n\t\t\t\tg = givens( RŒæ[j,j], RŒæ[row_index, j], j, row_index )[1]\n\t\t\t\tRŒæ = g*RŒæ;\n\t\t\t\tG = g*G;\n\t\t\tend\n\n\t\t\t### now, from G we can update the other matrices\n\t\t\tG·µÄ = transpose(G)\n\t\t\tgÃÉ = G·µÄ[1 : end-1, end]\n\t\t\tgÃÇ = G·µÄ[end, end]\n\n\t\t\tQg = Q*gÃÉ;\n\t\t\tv_Œæ = Z'*( Œ¶*Qg + œÜŒæ .* gÃÇ )\n\t\t\tœÉ_Œæ = Qg'*Œ¶*Qg + (2*gÃÇ) * œÜŒæ'*Qg + gÃÇ^2*œÜ‚ÇÄ\n\n\t\t\tœÑ_Œæ¬≤ = œÉ_Œæ - norm( L‚Åª¬π * v_Œæ, 2 )^2\n\t\t\t# œÑ_Œæ (and hence œÑ_Œæ^2) must be bounded away from zero\n    \t\t# for the model to remain fully linear\n\t\t\tif œÑ_Œæ¬≤ > chol_pivot\n\n\t\t\t\tif id < 0\n\t\t\t\t\tid = new_result!( db, Œæ, F[] )\n\t\t\t\tend\n\t\t\t\tpush!(round4_indices, id)\t# accept the result\n\n\t\t\t\tœÑ_Œæ = sqrt(œÑ_Œæ¬≤)\n\n\t\t\t\t# zero-pad Q and multiply with G·µó\n\t\t\t\tQ = [\n\t\t\t\t\tQ \t\t\t\t\tzeros( size(Q,1), 1);\n\t\t\t\t\tzeros(1, size(Q,2)) 1\n\t\t\t\t] * G·µÄ\n\n\t\t\t\tZ = [\n\t\t\t\t\tZ  \t\t\t\t\t\tQg;\n\t\t\t\t\tzeros(1, size(Z,2)) \tgÃÇ\n\t\t\t\t]\n\n\t\t\t\tL = [\n\t\t\t\t\tL          zeros(size(L,1), 1) ;\n\t\t\t\t\tv_Œæ'L‚Åª¬π'   œÑ_Œæ\n\t\t\t\t]\n\n\t\t\t\tL‚Åª¬π = [\n\t\t\t\t\tL‚Åª¬π                zeros(size(L‚Åª¬π,1),1);\n\t\t\t\t\t-(v_Œæ'L‚Åª¬π'L‚Åª¬π)./œÑ_Œæ   1/œÑ_Œæ\n\t\t\t\t]\n\n\t\t\t\tR = RŒæ\n\n\t\t\t\t# finally, augment basis matrices and add new kernel for next iteration\n\t\t\t\tŒ† = [ Œ† œÄŒæ ]\n\n\t\t\t\tŒ¶ = [\n\t\t\t\t\tŒ¶   œÜŒæ;\n\t\t\t\t\tœÜŒæ' œÜ‚ÇÄ\n\t\t\t\t]\n\t\t\t\tpush!( kernels, RBF.make_kernel(œÜ, Œæ) )\n\n\t\t\t\t# assert all( diag( L * L‚Åª¬π) .‚âà 1 )\n\t\t\t\tN += 1\n\t\t\tend#if\n\t\tend#for\n\t\tappend!(meta.round4_indices, round4_indices)\n\t\t@logmsg loglevel3 \"Round4: found $(length(round4_indices)) additional sites.\"\n\tend#if\n\n\treturn meta\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"note: Note\nAt the moment, we do not store the matrices calculated in round 4 of the update procedure. This could be done to save some work when actually calculating the coefficients.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"In contrast to the old RBF mechanism, the models in RadialBasisFunctionModels sometimes accept 2 parameters for the kernel. We use this little helper, to get defaults from the shape parameter. Note, that sanity check are performed in the RbfConfig constructor.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function _get_kernel_params( Œî , cfg )\n\n\tF = eltype(Œî)\n\n\tsp = if cfg.shape_parameter isa String\n\t\tparse_shape_param_string( Œî, sp )\n\telse\n\t\tF(cfg.shape_parameter)\n\tend\n\n\tisnan(sp) && return nothing\n\n\tkernel_name = cfg.kernel\n\n\tif kernel_name == :gaussian\n\t\treturn sp\n\telseif kernel_name == :inv_multiquadric\n\t\treturn (sp, 1//2)\n\telseif kernel_name == :multiquadric\n\t\treturn (sp, 1//2)\n\telseif kernel_name == :cubic\n\t\treturn Int(sp)\n\telseif kernel_name == :thin_plate_spline\n\t\treturn Int(sp)\n\telse\n\t\treturn sp\n\tend\nend\n\nfunction _get_radial_function( Œî, cfg )\n\tkernel_params = _get_kernel_params( Œî, cfg )\n\n\treturn RBF._get_rad_func( cfg.kernel, kernel_params )\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"An improvement step consists of adding a new site to the database, along an improving direction:","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function prepare_improve_model( mod :: Union{Nothing, RbfModel}, objf :: AbstractObjective,\n\tmeta :: RbfMeta, mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB,\n\talgo_config :: AbstractConfig; kwargs... )\n\tif !meta.fully_linear\n\t\tif isempty(meta.improving_directions)\n\t\t\t@warn \"RBF model is not fully linear, but there are no improving directions.\"\n\t\telse\n\t\t\tcfg = model_cfg(objf)\n\t\t\tpiv_val_1 = F.(get_Œî(iter_data) * cfg.Œ∏_enlarge_1 * cfg.Œ∏_pivot)\n\n\t\t\tsuccess = false\n\t\t\tdir = popfirst!( meta.improving_directions )\n\t\t\tlen = intersect_bounds( x, dir, lb_1, ub_2; return_vals = :absmax )\n\t\t\toffset = len .* dir\n\t\t\tif norm( offset, Inf ) > piv_val_1\n\t\t\t\tnew_id = new_result!( db, x .+ offset, F[] )\n\t\t\t\tpush!(new_indices, new_id)\n\t\t\t\tsuccess = true\n\t\t\tend\n\n\t\t\tsuccess && @logmsg loglevel3 \"Performed an improvement step.\"\n\t\t\tif isempty( meta.improving_directions ) && success\n\t\t\t\tmeta.fully_linear = true\n\t\t\t\t@logmsg loglevel3 \"The RBF Model is now fully linear.\"\n\t\t\tend\n\t\tend\n\tend\n\treturn meta\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"Now, in the 2-phase construction process, first all prepare_ functions are called for all surrogate models. Then, the unevaluated results are evaluated and we can proceed with the model building. As before, _init_model simply delegates work to update_model.","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function _init_model( cfg :: RbfConfig, objf :: AbstractObjective, mop :: AbstractMOP,\n\titer_data :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig, meta :: RbfMeta; kwargs... )\n\treturn update_model( nothing, objf, meta, mop, iter_data, db, ac; kwargs... )\nend\n\nfunction update_model( mod::Union{Nothing,RbfModel}, objf:: AbstractObjective, meta :: RbfMeta,\n\tmop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig;\n\tkwargs... )\n\n\tŒî = get_Œî(iter_data)\n\tcfg = model_cfg(objf)\n\n\tx = get_x(iter_data)\n\tF = eltype(x)\n\n\tkernel_params = _get_kernel_params( Œî, cfg )\n\n\t# get the training data from `meta` and the database `db`\n\ttraining_indices = _collect_indices( meta )\n\ttraining_results = get_result.( db, training_indices )\n\ttraining_sites = get_site.( training_results )\n\toi = output_indices( objf, mop)\t# only consider the objective output indices\n\ttraining_values = [ v[oi] for v in get_value.( training_results ) ]\n\n\tinner_model = RBF.RBFInterpolationModel( training_sites, training_values, cfg.kernel, kernel_params; save_matrices = false )\n\n\treturn RbfModel( inner_model, meta.fully_linear ), meta\n\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"The improvement function also simply cals the update function:","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"function improve_model( mod::Union{Nothing,RbfModel}, objf:: AbstractObjective, meta :: RbfMeta,\n\tmop :: AbstractMOP, id :: AbstractIterData, db :: AbstractDB, ac :: AbstractConfig; kwargs... )\n\treturn update_model( mod, objf, meta, mop, id, db, ac; kwargs... )\nend","category":"page"},{"location":"RbfModel/#Evaluation","page":"RbfModels","title":"Evaluation","text":"","category":"section"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"All the work is done by the inner model :)","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"\"Evaluate `mod::RbfModel` at scaled site `xÃÇ`.\"\nfunction eval_models( mod :: RbfModel, xÃÇ :: Vec)\n\treturn mod.model( xÃÇ )\nend\n\n\"Evaluate output `‚Ñì` of `mod::RbfModel` at scaled site `xÃÇ`.\"\nfunction eval_models( mod :: RbfModel, xÃÇ :: Vec, ‚Ñì :: Int)\n\treturn mod.model( xÃÇ, ‚Ñì)\nend\n\n@doc \"Gradient vector of output `‚Ñì` of `mod` at scaled site `xÃÇ`.\"\nfunction get_gradient( mod :: RbfModel, xÃÇ :: Vec, ‚Ñì :: Int64)\n    return RBF.grad( mod.model, xÃÇ, ‚Ñì )\nend\n\n@doc \"Jacobian Matrix of ExactModel `em` at scaled site `xÃÇ`.\"\nfunction get_jacobian( mod :: RbfModel, xÃÇ :: Vec )\n    return RBF.jac( mod.model, xÃÇ )\nend","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"[wild_diss]: ‚ÄúDerivative-Free Optimization Algorithms For Computationally Expensive Functions‚Äù, Stefan M. Wild, 2009","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"","category":"page"},{"location":"RbfModel/","page":"RbfModels","title":"RbfModels","text":"This page was generated using Literate.jl.","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"EditURL = \"https://github.com/manuelbb-upb/Morbit.jl/blob/master/src/custom_logging.jl\"","category":"page"},{"location":"custom_logging/#Printing-Debug-Info","page":"Debug Info","title":"Printing Debug Info","text":"","category":"section"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"We provide a custom formatter method and define our own log levels. The user can choose, how much information is printed and it should look nicer this way.","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"Log messages are only displayed if they have a LogLevel that is ‚â• than a minimum log-level defined for the current logger. The current minimum log-level can be determined with","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"Logging.min_enabled_level( Logging.current_logger() )","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"For more information see the docs. Usually, the minimum log level is -1.","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"We have the following LogLevels and they can be referred to as Morbit.loglevel1 ect.:","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"const loglevel1 = LogLevel(-1);\nconst loglevel2 = LogLevel(-2);\nconst loglevel3 = LogLevel(-3);\nconst loglevel4 = LogLevel(-4);\nnothing #hide","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"The can be made visible by setting one of these levels with a custom logger. For example, to see the most detailled messages, do something like this:","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"logger = Logging.ConsoleLogger( stderr, Morbit.loglevel4 )\nLogging.global_logger(logger)","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"Or use with_logger(logger) do ‚Ä¶ end to leave the global logger unchanged.","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"For prettier output, we define custom colors and indented prefixes:","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"const printDict = Dict(\n    loglevel1 => (:blue, \"Morbit\"),\n    loglevel2 => (:cyan, \"Morbit \"),\n    loglevel3 => (:green, \"Morbit  \"),\n    loglevel4 => (:green, \"Morbit   \")\n)","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"These are used in the morbit_formatter. The morbit_formatter can be enabled for a logger, such as Logging.ConsoleLogger, by passing the keyword argument meta_formatter, i.e.,","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"Logging.ConsoleLogger( stderr, Morbit.loglevel4; meta_formatter = morbit_formatter )","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"Note, that morbit_formatter is exported.","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"function morbit_formatter(level::LogLevel, _module, group, id, file, line)\n    @nospecialize\n\tglobal printDict\n    if level in keys(printDict)\n        color, prefix = printDict[ level ]","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"suffix ::String = \"\"","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"        return color, prefix, \"\"\n    else\n        return Logging.default_metafmt( level, _module, group, id, file, line )\n    end\nend","category":"page"},{"location":"custom_logging/#Shorthand-Function","page":"Debug Info","title":"Shorthand Function","text":"","category":"section"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"The following (unexported) function sets the global logger to print everything:","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"function print_all_logs()\n    Logging.global_logger( Logging.ConsoleLogger( stderr, Morbit.loglevel4; meta_formatter = morbit_formatter ) )\nend","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"","category":"page"},{"location":"custom_logging/","page":"Debug Info","title":"Debug Info","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"EditURL = \"https://github.com/manuelbb-upb/Morbit.jl/blob/master/examples/example_zdt.jl\"","category":"page"},{"location":"example_zdt/#ZDT3-Problem","page":"ZDT3","title":"ZDT3 Problem","text":"","category":"section"},{"location":"example_zdt/#Setup","page":"ZDT3","title":"Setup","text":"","category":"section"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"Install the test problem suite:","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"using Pkg\nPkg.activate(tempname())\nPkg.develop(url=\"https://github.com/manuelbb-upb/MultiObjectiveProblems.jl\")\nusing MultiObjectiveProblems","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"using MultiObjectiveProblems; #hide\nnothing #hide","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"Import other dependencies:","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"using CairoMakie\nusing Morbit","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"Retrieve test problem and define a MixedMOP","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"test_problem = ZDT3(2);\nbox = constraints(test_problem);\n\nobjectives = get_objectives(test_problem)\nx‚ÇÄ = get_random_point(test_problem)\n\nmop = MixedMOP( box.lb, box.ub );\nobjf_cfg = ExactConfig()\nfor objf ‚àà objectives\n    add_objective!(mop, objf, objf_cfg)\nend","category":"page"},{"location":"example_zdt/#Run","page":"ZDT3","title":"Run","text":"","category":"section"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"Run optimization and plot:","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"I = get_ideal_point(test_problem)\nac = AlgoConfig(; descent_method = :ps, reference_point = I )\n\nx, fx, id = optimize( mop, x‚ÇÄ; algo_config = ac);\n\npset = get_pareto_set(test_problem)\nPSx,PSy = get_scatter_points(pset, 100)\n\n#  scatter Pareto set points in grey\nfig, ax, _ = scatter( PSx, PSy;\n    figure = (resolution = (600, 650),),\n)\n\n#  set axis limits to whole feasible set\nxlims!(ax, (box.lb[1] .- .2, box.ub[1] .+ .2) )\nylims!(ax, (box.lb[2] .- .2, box.ub[2] .+ .2) )\n\n#  final iterate in red\nscatter!(Tuple(x); color = :red)\n\nfig","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"","category":"page"},{"location":"example_zdt/","page":"ZDT3","title":"ZDT3","text":"This page was generated using Literate.jl.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"EditURL = \"https://github.com/manuelbb-upb/Morbit.jl/blob/master/src/TaylorModel.jl\"","category":"page"},{"location":"TaylorModel/#Taylor-Polynomial-Models","page":"TaylorModels","title":"Taylor Polynomial Models","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"We provide vector valued polynomial Taylor models of degree 1 or 2. They implement the SurrogateModel interface.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"We allow the user to either provide gradient and hessian callback handles or to request finite difference approximations. For using callbacks, we have TaylorConfigCallbacks. \nThere are two ways to use finite differences. The old (not recommended way) is to use TaylorConfigFiniteDiff. This uses FiniteDiff.jl and could potentially require more evaluations. \nTo make use of the new 2-phase construction procedure, use TaylorConfig and set the fields gradients and hessians to an RFD.FiniteDiffStamp. If they use the same stamp (default: RFD.CFDStamp(1,3) :: CFDStamp{3,Float64}), it should be the most efficient, because we get the gradients for free from computing the hessians.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"include(\"RecursiveFiniteDifferences.jl\")\n\nusing .RecursiveFiniteDifferences\nconst RFD = RecursiveFiniteDifferences","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The actual model is defined only by the gradient vectors at x‚ÇÄ and the Hessians (if applicable).","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"@with_kw struct TaylorModel{\n    XT <: AbstractVector{<:Real}, FXT <: AbstractVector{<:Real},\n    G <: AbstractVector{<:AbstractVector{<:Real}},\n    HT <: Union{Nothing,AbstractVector{<:AbstractMatrix{<:Real}}},\n    } <: SurrogateModel\n\n    # expansion point and value\n    x0 :: XT\n    fx0 :: FXT\n\n    # gradient(s) at x0\n    g :: G\n    H :: HT = nothing\nend\n\nfully_linear( :: TaylorModel ) = true","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Note, that the derivative approximations are actually constructed for the function(s)","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"    f_‚Ñì  s^-1","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"if some internal transformation s has happened before. If the problem is unbounded then s = operatornameid = s^-1.","category":"page"},{"location":"TaylorModel/#Model-Construction","page":"TaylorModels","title":"Model Construction","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Because of all the possibilities offered to the user, we actually have several (sub-)implementiations of SurrogateConfig for Taylor Models.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"abstract type TaylorCFG <: SurrogateConfig end","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"We make sure, that all subtypes have a field max_evals:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"max_evals( cfg :: TaylorCFG ) = cfg.max_evals","category":"page"},{"location":"TaylorModel/#Recursive-Finite-Difference-Models","page":"TaylorModels","title":"Recursive Finite Difference Models","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Let's start by defining the recommended way of using Taylor approximations. The derivative information is approximated using a dynamic programming approach and we take care to avoid unnecessary objective evaluations.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"@doc \"\"\"\n    TaylorConfig(; degree, gradients :: RFD.CFDStamp, hessians :: RFD.CFDStamp, max_evals)\n\nConfiguration for a polynomial Taylor model using finite difference approximations of the derivatives.\nBy default we have `degree = 2` and `gradients == hessians == RFD.CFDStamp(1,2)`, that is,\na first order central difference scheme of accuracy order 3 is recursed to compute the Hessians\nand the gradients.\nIn this case, the finite difference scheme is the same for both Hessians and gradients and we profit\nfrom caching intermediate results.\n\"\"\"\n@with_kw struct TaylorConfig{\n        S1 <: RFD.FiniteDiffStamp,\n        S2 <: Union{Nothing,RFD.FiniteDiffStamp}\n    } <: TaylorCFG\n\n    degree :: Int64 = 2\n\n    gradients :: S1 = RFD.CFDStamp(1,2)\n    hessians :: S2 = gradients\n\n    max_evals :: Int64 = typemax(Int64)\n\n    @assert 1 <= degree <= 2 \"Can only construct linear and quadratic polynomial Taylor models.\"\nend\n\ncombinable( :: TaylorConfig ) = true","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The new meta type only stores database indices of sites used for a finite diff approximation in the actual construction call and is filled in the prepare_XXX methods:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"@with_kw struct TaylorIndexMeta{W1, W2} <: SurrogateMeta\n    database_indices :: Vector{Int} = Int[]\n    grad_setter_indices :: Vector{Int} = Int[]\n    hess_setter_indices :: Vector{Int} = Int[]\n    hess_wrapper :: W1 = nothing\n    grad_wrapper :: W2 = nothing\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The end user won't be interested in the wrappers, so we put nothing in there:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"saveable_type( :: TaylorIndexMeta ) = TaylorIndexMeta{Nothing, Nothing}\nsaveable( meta :: TaylorIndexMeta ) = TaylorIndexMeta(;\n    grad_setter_indices = meta.grad_setter_indices,\n    hess_setter_indices = meta.hess_setter_indices\n)","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The new construction process it is a bit complicated. We set up a recursive finite diff tree and need this little helper:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"\"Return `unique_elems, indices = unique_with_indices(arr)` such that\n`unique_elems[indices] == arr` (and `unique_elems == unique(arr)`).\"\nfunction unique_with_indices( x :: AbstractVector{T} ) where T\n\tunique_elems = T[]\n\tindices = Int[]\n\tfor elem in x\n\t\ti = findfirst( e -> all( isequal.(e,elem) ), unique_elems )\n\t\tif isnothing(i)\n\t\t\tpush!(unique_elems, elem)\n\t\t\tpush!(indices, length(unique_elems) )\n\t\telse\n\t\t\tpush!(indices, i)\n\t\tend\n\tend\n\treturn unique_elems, indices\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Now, if the polynomial degree equals 2 we construct a tree for the Hessian calculation. In any case, we need a tree for the gradients/jacobian. If the RFD.FiniteDiffStamp for the gradients is the same as for the Hessians, we can re-use the Hessian tree for this purpose. Else, we need to construct a new one.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function _get_RFD_trees( x, fx, grad_stamp, hess_stamp = nothing, deg = 2)\n    if deg >= 2\n        @assert !isnothing(hess_stamp)\n        # construct tree for hessian first\n        hess_wrapper = RFD.DiffWrapper(; x0 = x, fx0 = fx, stamp = hess_stamp, order = 2 )\n    else\n        hess_wrapper = nothing\n    end\n\n    if !isnothing(hess_wrapper) && grad_stamp == hess_stamp\n        grad_wrapper = hess_wrapper\n    else\n        grad_wrapper = RFD.DiffWrapper(; x0 = x, fx0 = fx, stamp = grad_stamp, order = 1 )\n    end\n\n    return grad_wrapper, hess_wrapper\nend\n\n\nfunction prepare_init_model(cfg :: TaylorConfig, objf :: AbstractObjective,\n    mop :: AbstractMOP, iter_data ::AbstractIterData, db :: AbstractDB, algo_cfg :: AbstractConfig; kwargs...)\n\n    return prepare_update_model( nothing, objf, TaylorIndexMeta(), mop, iter_data, db, algo_cfg; kwargs... )\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The actual database preparations are delegated to the prepare_update_model function.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function prepare_update_model( mod :: Union{Nothing, TaylorModel}, objf, meta :: TaylorIndexMeta, mop,\n    iter_data, db, algo_cfg; kwargs... )\n\n    x = get_x( iter_data )\n    fx = get_fx( iter_data )\n    x_index = get_x_index( iter_data )\n\n    cfg = model_cfg( objf )\n\n    grad_wrapper, hess_wrapper = _get_RFD_trees( x, fx, cfg.gradients, cfg.hessians, cfg.degree )\n\n    XT = typeof(x)\n    FXT = typeof(fx)\n\n    lb, ub = full_bounds_internal( mop )\n\n    if cfg.degree >= 2\n        RFD.substitute_leaves!(hess_wrapper)\n        # We project into the scaled variable boundaries to avoid violations:\n        hess_sites = [ _project_into_box(s,lb,ub) for s in RFD.collect_leave_sites( hess_wrapper ) ]\n    else\n        hess_sites = XT[]\n    end\n\n    # collect leave sites for gradients\n    if grad_wrapper == hess_wrapper\n        grad_sites = hess_sites\n    else\n        RFD.substitute_leaves!( grad_wrapper )\n        grad_sites = [ _project_into_box(s, lb,ub) for s in RFD.collect_leave_sites( grad_wrapper ) ]\n    end\n\n    combined_sites = [ [x,]; hess_sites; grad_sites ]\n\n    unique_new, unique_indices = unique_with_indices(combined_sites)\n    # now: `combined_sites == unique_new[unique_indices]`\n\n    num_hess_sites = length(hess_sites)\n    hess_setter_indices = unique_indices[ 2 : num_hess_sites + 1]\n    grad_setter_indices = unique_indices[ num_hess_sites + 2 : end ]\n    # now: `hess_sites == unique_new[ hess_setter_indices ]` and\n    # `grad_sites == unique_new[ grad_setter_indices ]`\n\n    db_indices = [ [x_index,]; [ new_result!(db, Œæ, FXT()) for Œæ in unique_new[ 2:end ] ] ]\n    # now: `unique_new == get_site.(db, db_indices)`\n\n    # we return a new meta object in each iteration, so that the node cache is reset in between.\n    return TaylorIndexMeta(;\n        database_indices = db_indices,\n        grad_setter_indices,\n        hess_setter_indices,\n        grad_wrapper,\n        hess_wrapper\n    )\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"If the meta data is set correctly, we only have to set the value vectors for the RFD trees and then ask for the right matrices:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function _init_model( cfg :: TaylorConfig, objf :: AbstractObjective, mop :: AbstractMOP,\n    iter_data :: AbstractIterData, db :: AbstractDB, algo_config :: AbstractConfig, meta :: TaylorIndexMeta; kwargs... )\n    return update_model( nothing, objf, meta, mop, iter_data, db, algo_config; kwargs...)\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Note, that we only perform updates if the iterate has changed, x != mod.x0, because we don't change the differencing parameters.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function update_model( mod :: Union{Nothing, TaylorModel}, objf :: AbstractObjective, meta :: TaylorIndexMeta,\n    mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, algo_config :: AbstractConfig; kwargs...)\n\n    x = get_x(iter_data)\n    if isnothing(mod) || (x != mod.x0)\n        all_leave_vals = get_value.( db, meta.database_indices )\n\n        if !isnothing( meta.hess_wrapper )\n            hess_leave_vals = all_leave_vals[ meta.hess_setter_indices ]\n            RFD.set_leave_values!( meta.hess_wrapper, hess_leave_vals )\n            H = [ RFD.hessian( meta.hess_wrapper; output_index = ‚Ñì ) for ‚Ñì = 1 : num_outputs(objf) ]\n        else\n            H = nothing\n        end\n\n        # calculate gradients\n        if meta.hess_wrapper != meta.grad_wrapper\n            grad_leave_vals = all_leave_vals[ meta.grad_setter_indices ]\n            RFD.set_leave_values!( meta.grad_wrapper, grad_leave_vals )\n        end\n\n        # if hessians have been calculated before and `grad_wrapper == hess_wrapper` we profit from caching\n        J = RFD.jacobian( meta.grad_wrapper )\n        g = copy.( eachrow( J ) )\n\n        return TaylorModel(;\n            x0 = x,\n            fx0 = get_fx( iter_data ),\n            g, H\n        ), meta\n    else\n        return mod,meta\n    end\nend","category":"page"},{"location":"TaylorModel/#Callback-Models-with-Derivatives,-AD-or-Adaptive-Finite-Differencing","page":"TaylorModels","title":"Callback Models with Derivatives, AD or Adaptive Finite Differencing","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The old way of defining Taylor Models was to provide an objective callback function and either give callbacks for the derivatives too or ask for automatic differencing. This is very similar to the ExactModels, with the notable difference that the gradient and Hessian information is only used to construct models m_‚Ñì = f_0 + mathbf g^T mathbf h + mathbf h^T mathbf H mathbf h once per iteration and then use these m_‚Ñì for all subsequent model evaluations/differentiation.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"\"\"\"\n    TaylorCallbackConfig(;degree=1,gradients,hessians=nothing,max_evals=typemax(Int64))\n\nConfiguration for a linear or quadratic Taylor model where there are callbacks provided for the\ngradients and -- if applicable -- the Hessians.\nThe `gradients` keyword point to an array of callbacks where each callback evaluates\nthe gradient of one of the outputs.\n\"\"\"\n@with_kw struct TaylorCallbackConfig{\n        G <:Union{Nothing,AbstractVector{<:Function}},\n        J <:Union{Nothing,Function},\n        H <:Union{Nothing,AbstractVector{<:Function}},\n    } <: TaylorCFG\n\n    degree :: Int64 = 1\n    gradients :: G\n    jacobian :: J = nothing\n    hessians :: H = nothing\n\n    max_evals :: Int64 = typemax(Int64)\n\n    @assert 1 <= degree <= 2 \"Can only construct linear and quadratic polynomial Taylor models.\"\n    @assert !(isnothing(gradients) && isnothing(jacobian)) \"Provide either `gradients` or `jacobian`.\"\n    @assert isa( gradients, AbstractVector ) && !isempty( gradients ) || !isnothing(jacobian) \"Provide either `gradients` or `jacobian`.\"\n    @assert !(isnothing(gradients)) && ( isnothing(hessians) || length(gradients) == length(hessians) ) \"Provide same number of gradients and hessians.\"\nend\n\n\"\"\"\n    TaylorApproximateConfig(;degree=1,mode=:fdm,max_evals=typemax(Int64))\n\nConfigure a linear or quadratic Taylor model where the gradients and Hessians are constructed\neither by finite differencing (`mode = :fdm`) or automatic differencing (`mode = :autodiff`).\n\"\"\"\n@with_kw struct TaylorApproximateConfig <: TaylorCFG\n    degree :: Int64 = 1\n\n    mode :: Symbol = :fdm\n\n    max_evals :: Int64 = typemax(Int64)\n\n    @assert 1 <= degree <= 2 \"Can only construct linear and quadratic polynomial Taylor models.\"\n    @assert mode in [:fdm, :autodiff] \"Use `mode = :fdm` or `mode = :autodiff`.\"\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"For these models, it is not advisable to combine objectives:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"combinable( :: Union{TaylorCallbackConfig, TaylorApproximateConfig}) = false","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"In both cases we transfer the finalized callbacks to the same meta structs. In fact, GW and HW are DiffFns as defined in src/diff_wrappers.jl (or nothing):","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"struct TaylorMetaCallbacks{GW, HW} <: SurrogateMeta\n    gw :: GW\n    hw :: HW\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"Again, we have a tfn::TransformerFn that represents the (un)scaling. \nIf callbacks are provided, then we use the GradWrapper and the HessWrapper.","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function init_meta( cfg :: TaylorCallbackConfig, objf, tfn )\n    gw = GradWrapper( tfn, cfg.gradients, cfg.jacobian )\n    hw = cfg.degree == 2 ? isa( cfg.hessians, AbstractVector{<:Function} ) ?\n        HessWrapper(tfn, cfg.hessians ) : nothing : nothing;\n    return TaylorMetaCallbacks( gw, hw )\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"If no callbacks are provided, we inspect the mode and use the corresponding wrappers:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function init_meta( cfg :: TaylorApproximateConfig, objf, tfn )\n    if cfg.mode == :fdm\n        gw = FiniteDiffWrapper(objf, tfn, nothing)\n    else\n        gw = AutoDiffWrapper( objf, tfn, nothing )\n    end\n    hw = cfg.degree == 2 ? HessFromGrads(gw) : nothing\n    return TaylorMetaCallbacks( gw, hw )\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The initialization for the legacy config types is straightforward as they don't use the new 2-phase process:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function prepare_init_model(cfg :: Union{TaylorCallbackConfig, TaylorApproximateConfig}, objf :: AbstractObjective,\n    mop :: AbstractMOP, ::AbstractIterData, ::AbstractDB, :: AbstractConfig; kwargs...)\n    tfn = TransformerFn(mop)\n    return init_meta( cfg, objf, tfn )\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The model construction happens in the update_model method and makes use of the get_gradient and get_hessian methods for the wrappers stored in meta:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function _init_model(cfg :: Union{TaylorCallbackConfig, TaylorApproximateConfig}, objf :: AbstractObjective,\n    mop :: AbstractMOP, iter_data ::AbstractIterData, db ::AbstractDB, algo_config :: AbstractConfig,\n    meta :: TaylorMetaCallbacks; kwargs...)\n    return update_model(nothing, objf, meta, mop, iter_data, db, algo_config; kwargs...)\nend\n\nfunction update_model( mod :: Union{Nothing,TaylorModel}, objf :: AbstractObjective, meta :: TaylorMetaCallbacks,\n    mop :: AbstractMOP, iter_data :: AbstractIterData, db :: AbstractDB, algo_config :: AbstractConfig; kwargs...)\n\n    x = get_x(iter_data)\n    if isnothing(mod) || (x != mod.x0)\n        fx = get_fx( iter_data )\n\n        num_out = num_outputs( objf )\n        g = [ get_gradient(meta.gw , x , ‚Ñì ) for ‚Ñì = 1 : num_out ]\n\n        if !isnothing(meta.hw)\n            H = [ get_hessian(meta.hw, x, ‚Ñì) for ‚Ñì = 1 : num_out ]\n        else\n            H = nothing\n        end\n\n        return TaylorModel(; x0 = x, fx0 = fx, g, H ), meta\n    else\n        return mod, meta\n    end\n\nend","category":"page"},{"location":"TaylorModel/#Model-Evaluation","page":"TaylorModels","title":"Model Evaluation","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The evaluation of a Taylor model of form","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"    m_‚Ñì(mathbf x) = f_‚Ñì(mathbf x_0) +\n    mathbf g^T ( mathbf x - mathbf x_0 ) + ( mathbf x - mathbf x_0 )^T mathbf H_‚Ñì ( mathbf x - mathbf x_0)","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"is straightforward:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"\"Evaluate (internal) output `‚Ñì` of TaylorModel `tm`, provided a difference vector `h = x - x0`.\"\nfunction _eval_models( tm :: TaylorModel, h :: Vec, ‚Ñì :: Int )\n    ret_val = tm.fx0[‚Ñì] + tm.g[‚Ñì]'h\n    if !isnothing(tm.H)\n        ret_val += .5 * h'tm.H[‚Ñì]*h\n    end\n    return ret_val\nend\n\n\"Evaluate (internal) output `‚Ñì` of `tm` at scaled site `xÃÇ`.\"\nfunction eval_models( tm :: TaylorModel, xÃÇ :: Vec, ‚Ñì :: Int )\n    h = xÃÇ .- tm.x0\n    return _eval_models( tm, h, ‚Ñì)\n end","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"For the vector valued model, we iterate over all (internal) outputs:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function eval_models( tm :: TaylorModel, xÃÇ :: Vec )\n    h = xÃÇ .- tm.x0\n    return [ _eval_models(tm, h, ‚Ñì) for ‚Ñì = eachindex(tm.g)]\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The gradient of m_‚Ñì can easily be determined:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function get_gradient( tm :: TaylorModel, xÃÇ :: Vec, ‚Ñì :: Int)\n    if isnothing(tm.H)\n        return tm.g[‚Ñì]\n    else\n        h = xÃÇ .- tm.x0\n        return tm.g[‚Ñì] .+ .5 * ( tm.H[‚Ñì]' + tm.H[‚Ñì] ) * h\n    end\nend","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"And for the Jacobian, we again iterate:","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"function get_jacobian( tm :: TaylorModel, xÃÇ :: Vec )\n    grad_list = [ get_gradient(tm, xÃÇ, ‚Ñì) for ‚Ñì=eachindex( tm.g ) ]\n    return transpose( hcat( grad_list... ) )\nend","category":"page"},{"location":"TaylorModel/#Summary-and-Quick-Examples","page":"TaylorModels","title":"Summary & Quick Examples","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"The recommended way to use Finite Difference Taylor models is to define them with TaylorConfig, i.e.,\nadd_objective!(mop, f, TaylorConfig())\nTo use FiniteDiff.jl instead, do\nadd_objective!(mop, f, TaylorApproximateConfig(; mode = :fdm))\nHave callbacks for the gradients and the Hessians? Great!\nadd_objective!(mop, f, TaylorCallbackConfig(; degree = 1, gradients = [g1,g2]))\nNo callbacks, but you want the correct matrices anyways? ForwardDiff to the rescue:\nadd_objective!(mop, f, TaylorApproximateConfig(; degree = 2, mode = :autodiff)","category":"page"},{"location":"TaylorModel/#Complete-usage-example","page":"TaylorModels","title":"Complete usage example","text":"","category":"section"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"using Morbit\nMorbit.print_all_logs()\nmop = MixedMOP(3)\n\nadd_objective!( mop, x -> sum( ( x .- 1 ).^2 ), Morbit.TaylorApproximateConfig(;degree=2,mode=:fdm) )\nadd_objective!( mop, x -> sum( ( x .+ 1 ).^2 ), Morbit.TaylorApproximateConfig(;degree=2,mode=:autodiff) )\n\nx_fin, f_fin, _ = optimize( mop, [-œÄ, ‚ÑØ, 0])","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"","category":"page"},{"location":"TaylorModel/","page":"TaylorModels","title":"TaylorModels","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Morbit","category":"page"},{"location":"#Morbit","page":"Home","title":"Morbit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package Morbit.jl provides a local derivative-free solver for multiobjective optimization problems with possibly expensive objectives. It is meant to find a single Pareto-critical point, not a good covering of the global Pareto Set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"‚ÄúMorbit‚Äù stands for Multiobjective Optimization by Radial Basis Function Interpolation in Trust-regions.  The name was chosen so as to pay honors to the single objective algorithm ORBIT by Wild et. al.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have a paper explaining the algorithm!","category":"page"},{"location":"","page":"Home","title":"Home","text":"This was my first project using Julia and there have been many messy rewrites. Nonetheless, the solver should now work sufficiently well to tackle most problems.  I hope to rewrite the custom types soonish. At the moment they are weakly typed and the performance suffers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"**To get started, see the examples, e.g. Two Parabolas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project was founded by the European Region Development Fund.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://www.efre.nrw.de/fileadmin/Logos/EU-Fo__rderhinweis__EFRE_/EFRE_Foerderhinweis_englisch_farbig.jpg\" width=\"45%\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://www.efre.nrw.de/fileadmin/Logos/Programm_EFRE.NRW/Ziel2NRW_RGB_1809_jpg.jpg\" width=\"45%\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Morbit]","category":"page"},{"location":"#Morbit.RbfConfig","page":"Home","title":"Morbit.RbfConfig","text":"RbfConfig(; kwarg1 = val1, ‚Ä¶ )\n\nConfiguration type for local RBF surrogate models.\n\nTo choose a kernel, use the kwarg kernel and a value of either  :cubic (default), :inv_multiquadric, :multiquadric, :gaussian or :thin_plate_spline. The kwarg shape_parameter takes a constant number or a string  that defines a calculation on Œî, e.g, \"Œî/10\". Note, that shape_parameter has a different meaning for the different kernels. For `:gaussian, :inv_multiquadric, :multiquadric it actually is a floating point shapeparameter. For :cubic it is the (odd) integer exponent and for `thinplate_splineit is an integer exponent as well. UseNaN` for defaults.\n\nTo see other configuration parameters use fieldnames(Morbit.RbfConfig). They have individual docstrings attached.\n\n\n\n\n\n","category":"type"},{"location":"#Morbit.TaylorApproximateConfig","page":"Home","title":"Morbit.TaylorApproximateConfig","text":"TaylorApproximateConfig(;degree=1,mode=:fdm,max_evals=typemax(Int64))\n\nConfigure a linear or quadratic Taylor model where the gradients and Hessians are constructed  either by finite differencing (mode = :fdm) or automatic differencing (mode = :autodiff).\n\n\n\n\n\n","category":"type"},{"location":"#Morbit.TaylorCallbackConfig","page":"Home","title":"Morbit.TaylorCallbackConfig","text":"TaylorCallbackConfig(;degree=1,gradients,hessians=nothing,max_evals=typemax(Int64))\n\nConfiguration for a linear or quadratic Taylor model where there are callbacks provided for the  gradients and ‚Äì if applicable ‚Äì the Hessians. The gradients keyword point to an array of callbacks where each callback evaluates  the gradient of one of the outputs.\n\n\n\n\n\n","category":"type"},{"location":"#Morbit.TaylorConfig","page":"Home","title":"Morbit.TaylorConfig","text":"TaylorConfig(; degree, gradients :: RFD.CFDStamp, hessians :: RFD.CFDStamp, max_evals)\n\nConfiguration for a polynomial Taylor model using finite difference approximations of the derivatives. By default we have degree = 2 and gradients == hessians == RFD.CFDStamp(1,2), that is,  a first order central difference scheme of accuracy order 3 is recursed to compute the Hessians  and the gradients. In this case, the finite difference scheme is the same for both Hessians and gradients and we profit  from caching intermediate results.\n\n\n\n\n\n","category":"type"},{"location":"#Morbit.TransformerFn","page":"Home","title":"Morbit.TransformerFn","text":"Return the TransformerFn defined by mop with a minimum precision of T.\n\n\n\n\n\n","category":"type"},{"location":"#Morbit.TransformerFn-Tuple{AbstractVector{var\"#s72\"} where var\"#s72\"<:Real}","page":"Home","title":"Morbit.TransformerFn","text":"Unscale the point xÃÇ from internal to original domain.\n\n\n\n\n\n","category":"method"},{"location":"#Base.eachindex-Tuple{Morbit.AbstractDB}","page":"Home","title":"Base.eachindex","text":"List of all id :: Int belonging to the stored results.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Morbit.AbstractDB}","page":"Home","title":"Base.length","text":"Number of entries in database.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._add!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective, Union{Nothing, Vector{Int64}}}","page":"Home","title":"Morbit._add!","text":"Add an objective function to MOP with specified output indices.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._backtrack-NTuple{5, Any}","page":"Home","title":"Morbit._backtrack","text":"Perform a backtracking loop starting at x with an initial step of step_size .* dir and return trial point x‚Çä, the surrogate value-vector m_x‚Çä and the final step s = x‚Çä .- x.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._del!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}","page":"Home","title":"Morbit._del!","text":"Remove an objective function from MOP.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit._eval_models","text":"Evaluate (internal) output ‚Ñì of TaylorModel tm, provided a difference vector h = x - x0.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._get_optim_handle-Tuple{Morbit.SurrogateModel, Int64}","page":"Home","title":"Morbit._get_optim_handle","text":"Return a function handle to be used with NLopt for output ‚Ñì of model. That is, if model is a surrogate for two scalar objectives, then ‚Ñì must  be either 1 or 2.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._get_ps_constraint_func-Tuple{Morbit.SurrogateContainer, Any, Any, Any}","page":"Home","title":"Morbit._get_ps_constraint_func","text":"_get_ps_constraint_func( sc :: SurrogateContainer, mx, dir, l )\n\nReturn the l-th (possibly non-linear) constraint function  for Pascoletti-Serafini. dir .>= 0 is the image direction; œá = [t;x] is the augmented variable vector;\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._get_ps_objective_func-Tuple{}","page":"Home","title":"Morbit._get_ps_objective_func","text":"Return objective function for Pascoletti-Serafini, modifying gradient in place.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._init_model-Tuple{ExactConfig, Morbit.AbstractObjective, Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig, Morbit.ExactMeta}","page":"Home","title":"Morbit._init_model","text":"Return an ExactModel build from a VectorObjectiveFunction objf.  Model is the same inside and outside of criticality round.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._intersect_bounds-NTuple{4, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit._intersect_bounds","text":"Return smallest positive and biggest negative and œÉ‚Çä and œÉ‚Çã so that x .+ œÉ¬± .* d stays within bounds.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._local_bounds-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Union{Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit._local_bounds","text":"Return lower and upper bound vectors combining global and trust region constraints.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._objf_index-Tuple{Morbit.AbstractObjective, Morbit.AbstractMOP}","page":"Home","title":"Morbit._objf_index","text":"Position of objf in list_of_objectives(mop).\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._ps_optimization-Union{Tuple{F}, Tuple{Morbit.SurrogateContainer, Symbol, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64, AbstractVector{F}, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64, Int64}} where F","page":"Home","title":"Morbit._ps_optimization","text":"Construct and solve Pascoletti Serafini subproblem using surrogates from sc.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._steepest_descent_direction-Union{Tuple{F}, Tuple{AbstractVector{F}, AbstractMatrix{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}} where F<:AbstractFloat","page":"Home","title":"Morbit._steepest_descent_direction","text":"Provided x and the (surrogate) jacobian ‚àáF at x, as well as bounds lb and ub, return steepest multi descent direction.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._wrap_func-Union{Tuple{O}, Tuple{T}, Tuple{Type{var\"#s42\"} where var\"#s42\"<:Morbit.OutTypeWrapper{T, O}, Function, Morbit.SurrogateConfig, Int64, Int64}} where {T, O}","page":"Home","title":"Morbit._wrap_func","text":"A general constructor.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit._wrap_func-Union{Tuple{T}, Tuple{T, Function, Morbit.SurrogateConfig, Int64, Int64}} where T<:(Type{var\"#s42\"} where var\"#s42\"<:Morbit.AbstractObjective)","page":"Home","title":"Morbit._wrap_func","text":"A general constructor.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.add_objective!","page":"Home","title":"Morbit.add_objective!","text":"add_objective!( mop :: MixedMOP, func :: T where{T <: Function}, type :: Symbol = :expensive, n_out :: Int64 = 1, can_batch :: Bool = false )\n\nAdd scalar-valued objective function func to mop structure. func must take an Vec as its (first) argument, i.e. represent a function f ‚Ñù^n  ‚Ñù. type must either be :expensive or :cheap to determine whether the function is replaced by a surrogate model or not.\n\nIf type is :cheap and func takes 1 argument only then its gradient is calculated by ForwardDiff. A cheap function func with custom gradient function grad (representing f  ‚Ñù^n  ‚Ñù^n) is added by\n\nadd_objective!(mop, func, grad)\n\nThe optional argument n_out allows for the specification of vector-valued objective functions. This is mainly meant to be used for expensive functions that are in some sense inter-dependent.\n\nThe flag can_batch defaults to false so that the objective function is simply looped over a bunch of arguments if required. If can_batch == true then the objective function must be able to return an array of results when provided an array of input vectors (whilst still returning a single result, not a singleton array containing the result, for a single input vector).\n\nExamples\n\n# Define 2 scalar objective functions and a MOP ‚Ñù^2 ‚Üí ‚Ñù^2\n\nf1(x) =  x[1]^2 + x[2]\n\nf2(x) = exp(sum(x))\n‚àáf2(x) = exp(sum(x)) .* ones(2);\n\nmop = MixedMOP()\nadd_objective!(mop, f1, :cheap)     # gradient will be calculated using ForwardDiff\nadd_objective!(mop, f2, ‚àáf2 )       # gradient is provided\n\n\n\n\n\n","category":"function"},{"location":"#Morbit.add_objective!-Tuple{MixedMOP, Function, Function}","page":"Home","title":"Morbit.add_objective!","text":"add_objective!( mop :: MixedMOP, func :: T where{T <: Function}, grad :: T where{T <: Function})\n\nAdd scalar-valued objective function func and its vector-valued gradient grad to mop struture.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.add_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}","page":"Home","title":"Morbit.add_objective!","text":"Add a scalar objective to mop::MixedMOP modelled according to model_config.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.add_vector_objective!-Tuple{MixedMOP, Function, Morbit.SurrogateConfig}","page":"Home","title":"Morbit.add_vector_objective!","text":"Add a vector objective to mop::MixedMOP modelled according to model_config.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.combine-Union{Tuple{F}, Tuple{T}, Tuple{T, F}} where {T<:Morbit.AbstractObjective, F<:Morbit.AbstractObjective}","page":"Home","title":"Morbit.combine","text":"Combine two objectives. Only needed if combinable can return true.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.combine-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F<:Function, T<:Function}","page":"Home","title":"Morbit.combine","text":"Get a new function function handle stacking the output of func1 and func2.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.copy_db-Union{Tuple{DBT}, Tuple{DBT, Type}} where DBT<:Morbit.AbstractDB","page":"Home","title":"Morbit.copy_db","text":"Return a new database of same 'base' type but with different saveable type.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_all_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_all_objectives","text":"(Internally) Evaluate all objectives at site xÃÇ::Vec. Objective order might differ from order in which they were added.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_and_sort_objectives-Tuple{Morbit.AbstractMOP, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_and_sort_objectives","text":"Evaluate all objectives at site xÃÇ::Vec and sort the result according to the order in which objectives were added.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_handle-Tuple{Morbit.AbstractObjective}","page":"Home","title":"Morbit.eval_handle","text":"Return a function that evaluates an objective at an unscaled site.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.eval_models","text":"Evaluate output ‚Ñì of the ExactModel em at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{Morbit.ExactModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_models","text":"Evaluate the ExactModel em at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{Morbit.SurrogateContainer, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.eval_models","text":"Return model value for output l of sc at xÃÇ. Index l is assumed to be an internal index in the range of 1,‚Ä¶,nobjfs, where nobjfs is the total number of (scalarized) objectives stored in sc.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{Morbit.TaylorModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.eval_models","text":"Evaluate (internal) output ‚Ñì of tm at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.eval_models","text":"Evaluate output ‚Ñì of mod::RbfModel at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_models-Tuple{RbfModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_models","text":"Evaluate mod::RbfModel at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_objf","text":"Evaluate the objective at unscaled site x. and increase counter.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.eval_objf-Tuple{Morbit.AbstractObjective, Morbit.TransformerFn, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.eval_objf","text":"Evaluate the objective at scaled site xÃÇ with help of tfn. Used in diff_wrappers.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.full_lower_bounds-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.full_lower_bounds","text":"Return full vector of lower variable vectors for original problem.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.full_lower_bounds_internal-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.full_lower_bounds_internal","text":"Return lower variable bounds for scaled variables.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.full_upper_bounds-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.full_upper_bounds","text":"Return full vector of upper variable vectors for original problem.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.full_upper_bounds_internal-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.full_upper_bounds_internal","text":"Return upper variable bounds for scaled variables.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_gradient-Tuple{Morbit.ExactModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.get_gradient","text":"Gradient vector of output ‚Ñì of em at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_gradient-Tuple{Morbit.SurrogateContainer, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.get_gradient","text":"Return a gradient for output l of sc at xÃÇ. Index l is assumed to be an internal index in the range of 1,‚Ä¶,nobjfs, where nobjfs is the total number of (scalarized) objectives stored in sc.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_gradient-Tuple{RbfModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}","page":"Home","title":"Morbit.get_gradient","text":"Gradient vector of output ‚Ñì of mod at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_id-Tuple{Morbit.AbstractResult}","page":"Home","title":"Morbit.get_id","text":"get_id( res :: AbstractResult ) :: Int\n\nReturn the id of a result such that for the database db  conataining res it holds that get_result(db, id) == res.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_jacobian-Tuple{Morbit.ExactModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.get_jacobian","text":"Jacobian Matrix of ExactModel em at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_jacobian-Tuple{RbfModel, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}","page":"Home","title":"Morbit.get_jacobian","text":"Jacobian Matrix of ExactModel em at scaled site xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_optim_handle-Tuple{Morbit.SurrogateContainer, Int64}","page":"Home","title":"Morbit.get_optim_handle","text":"Return a function handle to be used with NLopt for output l of sc. Index l is assumed to be an internal index in the range of 1, ‚Ä¶, n_objfs, where n_objfs is the total number of (scalarized) objectives stored in sc.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_poised_set-Union{Tuple{Any}, Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T<:(AbstractArray{var\"#s158\", N} where {var\"#s158\"<:Real, N})","page":"Home","title":"Morbit.get_poised_set","text":"get_poised_set( basis, points; solver = :LN_BOBYQA, max_solver_evals = -1 )\n\nCompute a point set suited for polynomial interpolation.\n\nInput:\n\nbasis: A vector of polynomials constituting a basis for the polynomial space.\npoints: (optional) A set of candidate points to be tried for inclusion into the poised set.\nsolver: NLopt solver to use. Should be derivative-free.\nmax_solver_evals: Maximum number of evaluations in each optimization run. \n\nReturn:\n\npoised_points :: Vector{T} where T is either a Vector{F} or an SVector{n_vars, F} and F is the precision of the points in points, but at least Float32. \nlagrange_basis :: Vector{<:AbstractPolynomialLike}: The Lagrange basis corresponding to poised_points.\npoint_indices: An array indicating which points from points are also in poised_points. A positive entry corresponds to the index of a poised point in points. If a poised point is new, then the entry is -1.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_result-Union{Tuple{F}, Tuple{Morbit.AbstractDB{F}, Int64}} where F","page":"Home","title":"Morbit.get_result","text":"Get result with id from database db.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_scaling_poly-Tuple{Any, Any, Any}","page":"Home","title":"Morbit.get_scaling_poly","text":"Return vector of polynomials that scales variables from [lb, ub] to [0,1]^n.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_site-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F","page":"Home","title":"Morbit.get_site","text":"Return the site vector associated with a result.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_unscaling_poly-Tuple{Any, Any, Any}","page":"Home","title":"Morbit.get_unscaling_poly","text":"Return vector of polynomials that unscales variables from [0,1]^n to [lb,ub].\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.get_value-Union{Tuple{Morbit.AbstractResult{F}}, Tuple{F}} where F","page":"Home","title":"Morbit.get_value","text":"Return the value vector associated with a result.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.grow_radius-Tuple{Val{:standard}, Any, Any, Any}","page":"Home","title":"Morbit.grow_radius","text":"Grow radius according to min( Œî_max, Œ≥ * Œî ).\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.grow_radius-Tuple{Val{:steplength}, Any, Any, Any}","page":"Home","title":"Morbit.grow_radius","text":"Grow radius according to min( Œî_max, (Œ≥ + ||s||/Œî) * Œî )\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.inc_evals!","page":"Home","title":"Morbit.inc_evals!","text":"Increase evaluation count by N\n\n\n\n\n\n","category":"function"},{"location":"#Morbit.init_db-Tuple{Type{var\"#s43\"} where var\"#s43\"<:Morbit.AbstractDB, Type{var\"#s42\"} where var\"#s42\"<:AbstractFloat, Union{Type{var\"#s41\"} where var\"#s41\"<:Nothing, Type{var\"#s40\"} where var\"#s40\"<:Morbit.AbstractIterSaveable}}","page":"Home","title":"Morbit.init_db","text":"Constructor for empty database of type T.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.init_res-Union{Tuple{T}, Tuple{T, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Int64}} where T<:(Type{var\"#s72\"} where var\"#s72\"<:Morbit.AbstractResult)","page":"Home","title":"Morbit.init_res","text":"Constructor for a result, taking site and value vector and id in database.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.init_surrogates-Tuple{Morbit.AbstractMOP, Morbit.AbstractIterData, Morbit.AbstractDB, Morbit.AbstractConfig}","page":"Home","title":"Morbit.init_surrogates","text":"Return a SurrogateContainer initialized from the information provided in mop.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.is_transformed-Tuple{Morbit.AbstractDB}","page":"Home","title":"Morbit.is_transformed","text":"Bool indicating if the database data been transformed.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.list_of_objectives-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.list_of_objectives","text":"Return a list of AbstractVectorObjectives.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.local_bounds-Tuple{Morbit.AbstractMOP, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Union{Real, AbstractVector{var\"#s1\"} where var\"#s1\"<:Real}}","page":"Home","title":"Morbit.local_bounds","text":"Local bounds vectors lb_eff and ub_eff using scaled variable constraints from mop.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.make_set_lambda_poised-Union{Tuple{T}, Tuple{Any, AbstractArray{T, N} where N}} where T<:(AbstractArray{var\"#s158\", N} where {var\"#s158\"<:Real, N})","page":"Home","title":"Morbit.make_set_lambda_poised","text":"make_set_lambda_poised( basis, points; \n    LAMBDA = 1.5, solver = :LN_BOBYQA, max_solver_evals = -1, max_loops = -1, skip_indices = [1,] )\n\nMake the output of get_poised_set even better suited for interpolation.\n\nInput:\n\nbasis: A vector of polynomials constituting a Lagrange basis for the polynomial space.\npoints: The vector of points belonging to the Lagrange basis.\nLAMBDA :: Real > 1: Determines the quality of the interpolation. \nsolver: NLopt solver to use. Should be derivative-free.\nmax_solver_evals: Maximum number of evaluations in each optimization run. \nmax_loops: Maximum number of loops that try to make the set Œõ-poised.\nskip_indices: Inidices of points to discard last.\n\nReturn:\n\npoised_points :: Vector{T} where T is either a Vector{F} or an SVector{n_vars, F} and F is the precision of the points in points, but at least Float32. \nlagrange_basis :: Vector{<:AbstractPolynomialLike}: The Lagrange basis corresponding to poised_points.\npoint_indices: An array indicating which points from points are also in poised_points. A positive entry corresponds to the index of a poised point in points. If a poised point is new, then the entry is -1.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.max_evals-Tuple{Morbit.AbstractObjective}","page":"Home","title":"Morbit.max_evals","text":"(Soft) upper bound on the number of function calls. \n\n\n\n\n\n","category":"method"},{"location":"#Morbit.new_result!","page":"Home","title":"Morbit.new_result!","text":"Add a new result to the database, return its id of type Int.\n\n\n\n\n\n","category":"function"},{"location":"#Morbit.num_evals!-Tuple{Morbit.AbstractObjective, Int64}","page":"Home","title":"Morbit.num_evals!","text":"Set evaluation counter to N.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.num_evals-Tuple{Morbit.AbstractObjective}","page":"Home","title":"Morbit.num_evals","text":"Number of calls to the original objective function.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.num_objectives-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.num_objectives","text":"Number of scalar-valued objectives of the problem.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.pop_objf!-Tuple{Morbit.AbstractMOP, Morbit.AbstractObjective}","page":"Home","title":"Morbit.pop_objf!","text":"Remove objf from list_of_objectives(mop) and return its output indices.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.reset_evals!-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.reset_evals!","text":"Set evaluation counter to 0 for each VectorObjectiveFunction in m.vector_of_objectives.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.results_in_box_indices","page":"Home","title":"Morbit.results_in_box_indices","text":"Return indices of results in db that lie in a box with corners lb and ub.\n\n\n\n\n\n","category":"function"},{"location":"#Morbit.reverse_internal_sorting-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Morbit.AbstractMOP}","page":"Home","title":"Morbit.reverse_internal_sorting","text":"Sort an interal objective vector so that the objectives are in the order in which they were added.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.reverse_internal_sorting_indices-Tuple{Morbit.AbstractMOP}","page":"Home","title":"Morbit.reverse_internal_sorting_indices","text":"Return index vector so that an internal objective vector is sorted according to the order the objectives where added.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.scale-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Morbit.AbstractMOP}","page":"Home","title":"Morbit.scale","text":"Scale variables fully constrained to a closed interval to [0,1] internally.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.set_transformed!-Tuple{Morbit.AbstractDB, Bool}","page":"Home","title":"Morbit.set_transformed!","text":"Set the flag indicating whether the database data has been transformed or not.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.shrink_radius-Tuple{Val{:standard}, Any, Any, Any}","page":"Home","title":"Morbit.shrink_radius","text":"Shrink radius according to Œ≥ * Œî.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.shrink_radius-Tuple{Val{:steplength}, Any, Any, Any}","page":"Home","title":"Morbit.shrink_radius","text":"Shrink radius according to Œ≥ * ||s||.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.shrink_radius_much-Tuple{Val{:standard}, Any, Any, Any}","page":"Home","title":"Morbit.shrink_radius_much","text":"Shrink radius much according to Œ≥ * Œî.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.shrink_radius_much-Tuple{Val{:steplength}, Any, Any, Any}","page":"Home","title":"Morbit.shrink_radius_much","text":"Shrink radius according to Œ≥ * ||s||.\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.unique_with_indices-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"Morbit.unique_with_indices","text":"Return unique_elems, indices = unique_with_indices(arr) such that  unique_elems[indices] == arr (and unique_elems == unique(arr)).\n\n\n\n\n\n","category":"method"},{"location":"#Morbit.unscale-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Morbit.AbstractMOP}","page":"Home","title":"Morbit.unscale","text":"Reverse scaling for fully constrained variables from [0,1] to their former domain.\n\n\n\n\n\n","category":"method"}]
}
